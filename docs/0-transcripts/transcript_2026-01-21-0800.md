# Transcript: Architecture Docs, Error Handling, and SDK Bug Discovery

**Date:** 2026-01-21, 08:00
**Participants:** User [U], Claude [C], Tutor summary [T]


---

## Architecture Documentation

**[U]** Can you write out some architecture docs for this first version of the app? This is meant to be a guide for me to inspect the code mainly.

**[C]** Created `docs/architecture-v1.md` (389 lines). Key sections:

1. **Directory Structure** — Where everything lives
2. **Module Dependency Graph** — How pieces connect
3. **Core Types** — Every significant type with file locations and responsibilities
4. **Data Flow** — Three diagrams showing message flow, spawning, and verification
5. **Thread Safety Model** — Table of queues and what they protect
6. **Entry Point** — How `TavernApp.swift` wires dependencies
7. **Testing Strategy** — How to test with `MockClaudeCode`
8. **What's Not Implemented** — Known gaps


---

## Error Handling Bug and Design Principles

**[U]** Here's a principle to take notes on. Whenever we have an error message pop up to the users, Jake is competent, and he won't allow for just "there was an error" message. Every message that pops up to the user must be expected somehow by us, so that when it happens, we detect it and inform the user precisely about the situation. The internet is flakey, the world is a crummy place, and users will get disconnected from Claude, for instance, so we want to provide a reasonable amount of information for the user to actually troubleshoot things.

In the app when I send a message, I always get this response:

> Oops! Something went wrong at the spillway: The operation couldn't be completed. (ClaudeCodeSDK.ClaudeCodeError error 2.)

What does that even mean?

**[C]** Two things here:

1. **Design principle** — Jake's error messages must be diagnostic, not generic. Noted.
2. **Immediate bug** — "error 2" is useless. Let me dig into this.

Found it. "Error 2" is `jsonParsingError` — the SDK received a response it couldn't parse as JSON.

The issue is Swift's `Error` protocol. The SDK defines `localizedDescription` as a computed property, but that doesn't override the default. Swift needs `LocalizedError` conformance with `errorDescription`.

**[U]** Jake's error messages need to be informative, not necessarily diagnostic.

**[C]** Good distinction. Informative = tell users what they need to know to act. Not necessarily the technical diagnosis.

Created `TavernErrorMessages.swift` — maps every `ClaudeCodeError` case to a user-friendly message:

```swift
case .jsonParsingError(let underlyingError):
    return """
        Claude's response couldn't be parsed.
        This usually means something went wrong on Claude's end, or
        there's an environment issue (PATH, permissions, etc.)

        Try again. If it keeps happening, check Console.app for
        logs from "ClaudeCode" to see what Claude actually returned.
        """

case .rateLimitExceeded(let retryAfter):
    if let seconds = retryAfter {
        return """
            Rate limit hit — Claude needs a breather.
            Try again in \(Int(seconds)) seconds. The Tavern will wait.
            """
    }
    // ...
```

Updated `ChatViewModel` to use these messages when displaying errors.


---

## Root Cause Investigation

**[C]** Investigating the JSON parsing error...

**Discovery:** Claude CLI `--output-format json` returns a JSON **array** of events:
```json
[
  {"type":"system","subtype":"init",...},
  {"type":"assistant","message":{...}},
  {"type":"result","subtype":"success","result":"PONG",...}
]
```

But the SDK's `ResultMessage` expects a single JSON **object**. This is a mismatch between ClaudeCodeSDK and the actual Claude CLI output format.

**[U]** Another technical principle behind these errors is that if we define programs well, such as with GADTs, then we should know all the possible errors that can happen, and it forces us to think about a meaningful message for each one at design time, rather than as an afterthought.

**[C]** That's a key architectural principle — if we design with well-typed errors (sum types/ADTs), we enumerate all failure modes upfront and can guarantee comprehensive handling.

**[U]** You shouldn't have to require the user in the loop to test things. Autonomously, FYI, another principle.

**[C]** Noted. Tests should be autonomous — not require human interaction to run or verify.

Created `SDKDiagnosticTests.swift`:
- `testClaudeCodeIsInstalled()` — verifies CLI in PATH
- `testClaudeCodeReturnsValidJSON()` — checks version command output
- `testSimplePromptTextFormat()` — verifies text format works
- `testJsonFormatBug()` — documents the SDK bug (expects it to fail)

**[U]** Another principle I want you to take down: we need to instrument the debugging versions of the apps so thoroughly, such that if I tell you I ran into an issue, and nothing more, you could look through logs or other data output to narrow down the issue quickly.

**[C]** Instrumentation Principle noted. Added `config.enableDebugLogging = true` in `TavernApp.swift`.

**[U]** Lastly, the SDK is open source. We can always fork and fix, as needed.

**[C]** Good to know. For now, I've implemented a workaround — using `.text` format instead of `.json`:

```swift
// NOTE: Using .text format because ClaudeCodeSDK has a bug parsing
// the .json format (Claude CLI returns an array, SDK expects an object).
// This means we lose session ID tracking for now.
// FIX: Fork ClaudeCodeSDK and fix HeadlessBackend.swift to parse arrays

result = try await claude.runSinglePrompt(
    prompt: message,
    outputFormat: .text,  // Changed from .json
    options: options
)
```

Applied same fix to `MortalAgent.swift`.

**[T]** *Four design principles established:*

1. **Informative Error Principle** — Error messages shown to users must be informative and actionable, not just "something went wrong." Map every error case to a meaningful message at design time.

2. **Sum Type Error Design** — Use GADTs/sum types to enumerate all failure modes upfront. This forces us to handle every case and think about user messages at design time.

3. **Autonomous Testing Principle** — Tests should not require human interaction. They should run and verify results automatically.

4. **Instrumentation Principle** — Debug builds must be instrumented thoroughly enough that logs alone can narrow down issues without user explanation.

*SDK bug documented and worked around. Future fix: fork ClaudeCodeSDK and fix array parsing in HeadlessBackend.swift.*


---

## Test Fix and App Restart Workflow

*(Session compacted here — context continued)*

**[C]** Ran tests. One failure: `ChatViewModelTests.swift` test "Error is captured and displayed in chat" expects old error format.

Fixed test — changed assertion from `"went wrong"` to `"Network hiccup"` to match new `TavernErrorMessages` output.

All 172 tests pass.

**[U]** Another rule: when you run the app for the human to use, and then rebuild it, you should offer to restart the app for them, or in some cases even just do it autonomously. This will help the user's workflow be smoother when iterating on things.

**[C]** App Restart Workflow noted:
- When rebuilding an app that's running, offer to restart (or do it autonomously for clear cases like bug fixes)
- Keeps iteration smooth — no manual quit/relaunch needed

```bash
pkill -f "Tavern.app" 2>/dev/null
open .build/xcodebuild/Build/Products/Debug/Tavern.app
```


---

## Summary

**Files Created:**
- `docs/architecture-v1.md` — Comprehensive architecture guide
- `Sources/TavernCore/Errors/TavernErrorMessages.swift` — Error-to-message mapper
- `Tests/TavernTests/SDKDiagnosticTests.swift` — SDK diagnostic tests

**Files Modified:**
- `Sources/TavernCore/Chat/ChatViewModel.swift` — Uses TavernErrorMessages
- `Sources/TavernCore/Agents/Jake.swift` — Uses .text format (workaround)
- `Sources/TavernCore/Agents/MortalAgent.swift` — Uses .text format (workaround)
- `Sources/Tavern/TavernApp.swift` — Debug logging enabled
- `Tests/TavernCoreTests/ChatViewModelTests.swift` — Updated error expectation
- `CLAUDE.md` — Added Informative Error and Instrumentation principles

**Design Principles Documented:**
1. Informative Error Principle
2. Sum Type Error Design
3. Autonomous Testing Principle
4. Instrumentation Principle
5. App Restart Workflow
