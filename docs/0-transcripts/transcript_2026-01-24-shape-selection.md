# Transcript: Architecture Shape Selection

**Date:** 2026-01-24
**Session:** Architecture exploration, shape synthesis, ADR creation


## Context

Prior to this session, 48 architecture proposals were generated by spawning subagents in parallel. Each proposal included a 1-page summary and a detailed treatise. A synthesis report grouped them into 16 fundamental "shapes."


## Cellular/Emergent (Final Shape)

**[U]** "i think the only one from the list was cellular emergent behavior, that could be of interest. besides that, i think we've drained out all of the ideas from your head"

*[T] User identified the final unexplored shape after filtering out non-architectural patterns (attention tracking, overlay/shadow, consensus).*

**[C]** Spawned agent #49 for Cellular/Emergent architecture. Key findings:

- Fundamentally different from choreography: state observation vs event handling
- Agents apply local rules based on neighbor states, no communication protocol
- Conflicts with PRD's verification requirements (no authority to verify)
- Implementation estimate: 19-27 weeks (largest of any architecture)
- Recommendation: "File under interesting future direction, not v1 consideration"


## Compatibility Matrix Groupings

**[U]** "can you give some explanations for the compat combos, 2nd group?"

**[C]** Added explanations for the 75 compatible (✓) pairs.

**[U]** "just explain all of them"

**[C]** Updated synthesis report with full explanations for all 122 pairs across 5 compatibility levels:

| Group | Count | Description |
|-------|-------|-------------|
| ✓✓ Synergistic | 13 | Compounding benefits, amplify each other |
| ✓ Compatible | 75 | Work together, require integration effort |
| ~ Neutral | 24 | Orthogonal, no interaction |
| ✗ Tension | 8 | Pick one or integrate carefully |
| ✗✗ Conflict | 2 | Mutually exclusive |

The two conflicts:
- **Layer + Flat** — opposite by definition
- **Tree + Decentralization** — root authority vs no authority


## UI Responsiveness Question

**[U]** "which of these would be better for a more responsive UI, where the UI has to respond to changes in many other threads running simultaneously"

**[C]** Recommended:

1. **Reactive Streams (Shape A)** — primary answer, designed for "many producers, one consumer that mustn't block"
2. **Queue (Shape G)** — for batching if needed
3. **Shared Workspace (Shape E)** with observation — SwiftUI's native model

Key pattern: Combine + SwiftUI with debounce/throttle for rate limiting.


## Architecture Decision

**[U]** "decision time, the doc store is essentially a blackboard shared state, the job of agents is to work on that. the agents are managed in supervisor trees. updates to the UI are reactive. we might use swift actors at an implementation level for threading, but then my concern is managing thread pools or concurrency to fit limits. agents and spawners will be pluggable, because we'll have a wide variety of both (but it'll be a closed set of plugins), there will be some basic layering to make testing easier, messaging as a tool for agents will be over some kind of message bus that's layered on top of the basic channels agents have for managing the supervisor trees. we will probably need to use a minimal sidecar, so that both the agent is responsive to messages from anthropic, and also not blocking managing its child agents. we don't need fancy logic for the review and rewind, because that will be a semantic layer on top of the shared state."

*[T] User made the final architecture decision, selecting specific shapes.*

**[C]** Codified the decision:

| Shape | Role |
|-------|------|
| E: Shared Workspace | Doc store as blackboard |
| D: Supervisor Tree | Agent hierarchy with lifecycle |
| A: Reactive Streams | UI updates |
| A: Message Bus | Agent-to-agent messaging |
| I: Plugin | Closed set of agent types and spawners |
| C: Layer | Basic layering for testability |
| L: Sidecar | Agent responsiveness while managing children |

Compatibility check: All pairs ✓ or ✓✓, no conflicts. D+L is synergistic.


## ADR Creation

**[U]** "separate one"

**[C]** Created `ADR-001-shape-selection.md` with:
- Decision summary
- Context and constraints
- Alternatives considered (event sourcing, decentralization, formal methods, flat, cellular — all rejected)
- Detailed design (layer structure, sidecar pattern, plugin system, doc store, message bus, reactive UI)
- Consequences (positive, negative, risks)


## ViewModel Layer Addition

**[U]** "you also forgot the viewmodel layer for tiles and panels. also, the testing requirement is to make sure as much works without actual UI, so that the UI layer is really dumb and simplistic, thus you can do automated tests for a lot of the UX workflows easily"

*[T] User clarified the testability goal: thin UI, fat ViewModel, 90%+ of UX testable without SwiftUI.*

**[C]** Updated ADR with:

```
UI Layer (thin, dumb)           ← just layout + gestures
ViewModel Layer                 ← TileViewModel, PanelViewModel, all UX logic
Application Layer               ← Coordinator, Spawner
Agent Layer                     ← Jake, MortalAgent, Sidecar
Domain Layer                    ← Commitment, Assignment
Infrastructure Layer            ← DocStore, SDK
```

Added "Thin UI / Fat ViewModel" section with code examples showing testable ViewModels.


---

## Synthesis

___

[S] **Shape Selection Complete**

The architecture exploration is complete:
- 49 proposals generated across 16 shapes
- Compatibility matrix with 122 pair explanations
- Final selection: E + D + A + I + C + L (all compatible)
- ADR-001 documents the decision with rationale

Key principle: **Shapes are composable, not exclusive.** The question was never "which pattern?" but "which shapes compose well for our constraints?"

The selected combination satisfies:
- PRD's hierarchy (Tree)
- PRD's doc store invariant (Shared Workspace)
- UI responsiveness (Reactive Streams)
- Testability (Layers + thin UI)
- Extensibility (Plugin)
- Thread safety (Sidecar)

What we explicitly rejected:
- Event sourcing (review/rewind is semantic query, not replay)
- Decentralization (Jake is the coordinator)
- Formal verification beyond state machines
- Cellular/emergent (too speculative for v1)
