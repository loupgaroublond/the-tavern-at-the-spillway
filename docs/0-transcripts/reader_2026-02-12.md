# The Tavern at the Spillway — System Design Reader

**Date:** 2026-02-12

**Purpose:** This document synthesizes all discovery session transcripts into a standalone explanation of the system design. Read this instead of tailing transcripts.

**Previous reader:** `reader_2026-02-05.md` — This update incorporates the inception transcript (2026-01-18) and 15 additional transcripts from 2026-02-02 through 2026-02-12, covering: servitor naming, JSON-to-MCP migration, document pipeline formalization, spec enumeration, resource panel, autonomous testing infrastructure, two major swarm executions, multi-type file audit, property-based spec methodology, and V1 chat parity planning.


---


## 1. Executive Summary

The Tavern at the Spillway is a multi-agent orchestration framework with a custom macOS user interface. The system manages a swarm of AI agents working on development tasks, with a coordinating "daemon" agent (Jake) that spawns and manages task-specific "servitor" agents.

The core value proposition is solving the attention management problem: when using one AI agent, there is idle time; when using many, the human cannot track them all. This framework provides a dashboard and chat interface that surfaces the right agent conversations at the right time, allowing users to engage productively with multiple agents without being overwhelmed by notifications or missing critical questions.

The system is built on ClodKit v1.0.0 and ships as a macOS application with a GUI-less framework core for potential alternative interfaces.

**Current implementation state:** Jake responds in plain text with native MCP tools (`summon_servitor`, `dismiss_servitor`), two-mode agent spawning (user-spawn waits for input, Jake-spawn works immediately), agent persistence via UserDefaults, session history restoration, multi-project support with per-project session persistence, multi-window architecture, agent spawning with themed names and UI, content block rendering, window restoration on app restart, two-level orchestration model (Tavern agents for tracked work, Task subagents for ephemeral parallelism), resource panel (file tree browser + file viewer), permissions subsystem, slash command infrastructure (core + custom), streaming responses, multi-line input with @ file mentions. 574 tests passing (Grade 1+2: 542, Grade 3 integration: 32).


---


## 2. Problem Statement

These pain points drove the design (from transcript_2026-01-19-1026):


**Attention Management:**

- One Claude Code instance means waiting around with low efficiency

- Multiple instances require tracking all of them while engaging with any single one

- More than 5 sessions becomes impossible to manage while also doing focused work

- Permission requests from background agents interrupt focused conversations


**Tooling Gaps:**

- YOLO mode needs a sandbox; the built-in one does not fit; third-party tools make incorrect assumptions about git and worktrees

- IDE integration is janky in the terminal; VSCode plugin has different issues

- No good tool to balance jumping into code yourself vs letting the agent work

- Terminal-based TUIs are hard to manage; everyone settles on tmux-based solutions


**Coordination Problems:**

- Agents run free-for-all; fixes turn into complex pipelines

- Too many agents clobber each other when working on the same things

- Worktree management tools make gross assumptions about repo usage


**Workflow Rigidity:**

- Many workflows require deterministic shells to enforce correct execution; hooks constrain without flexibility

- Many frameworks do not manage "efficiency of quality" and allow agents to burn too many tokens

- Frameworks either have rigid workflows or no workflows at all


**Visibility Gaps:**

- No self-improvement of these systems

- Not enough telemetry to improve; heavy reliance on brute force

- TUI Claude Code smooshes everything together (thinking, tool use, coding, chat) making it unreadable


---


## 3. Core Concepts


### Jake (The Proprietor)

Jake is the top-level coordinating daemon agent. He is always running and manages the entire system. Key characteristics:

- **Daemon lifecycle:** Jake never dies; servitors are task-bound

- **Lowest privileges by quantity:** Jake has few direct capabilities but highest authority to spawn and manage other agents

- **First contact:** For a fresh project, the user's first interaction is with Jake

- **Task delegation:** Jake quickly fires up servitors to handle work, staying free for the next request

- **MCP tools:** Jake uses native MCP tools (`summon_servitor`, `dismiss_servitor`) registered via `TavernMCPServer` to manage the Slop Squad. This replaced an earlier JSON envelope hack where spawn commands were embedded in structured JSON responses (transcript_2026-02-02-1650, transcript_2026-02-06).

Jake has a distinctive voice (used car salesman energy, carnival barker theatrics), but this is presentation layer only. The work is flawless. Full character specification is in `jake-character.md`.

Jake is Jewish (doesn't make it his whole personality, but it's there). This is personal for him. One hard political line: nazis are not tolerated. The Tavern welcomes everyone. Except nazis.


### Servitors (The Regulars)

Agents spawned by Jake to complete specific tasks. Previously called "MortalAgent" in code — renamed to "Servitor" in the naming session (transcript_2026-02-02-1650).

**Naming layer separation:**

- **Code level (canonical names):** Servitor, ServitorSpawner, summon, dismiss

- **Character level (Jake's voice):** "The Regulars" (individuals), "Slop Squad" (the whole team)

This two-level terminology resolves overloading: "daemon" conflicted with Unix background processes, "agent" conflicted with LLM subagents. "Servitor" is distinct and theme-appropriate.

**Task Modes** (agents can bounce between these):

- Execute directly

- Delegate to a new child agent

- Plan more first

- Break into pieces and assign

- Unify work from delegated children

Servitors can have children, forming a tree structure per user request. Agent hierarchies are Erlang-style — arbitrary depth, no limits.


### Two-Level Orchestration Model

Jake operates a two-level agent system (transcript_2026-01-28):

**Level 1 — Tavern Agents** (via MCP tools):

- Full Claude Code sessions with their own context

- Appear in sidebar, persist across sessions

- For substantial, independent work streams

- Created via Jake's `summon_servitor` MCP tool

**Level 2 — Subagents** (via Task tool):

- Internal parallel workers within any agent's session

- Lightweight, ephemeral, don't persist

- For quick parallel tasks within a single work stream

- Any agent (including Jake) can spawn these directly via Task tool

**When to use which:** Spawn Tavern agent for tracked work ("help me build feature X"). Use Task tool for quick internal parallelism ("search these 5 files in parallel").


### Two-Mode Agent Spawning

Agent spawning has two modes depending on who initiates (transcript_2026-01-27):

**User-spawn:** User clicks `+` in toolbar. No dialog — agent is created instantly with a system prompt that tells it to wait for the user's first message. The user types their request into the normal chat UI.

**Jake-spawn:** Jake decides to delegate work. Agent is created with an assignment and a system prompt that tells it to work on the assignment immediately before waiting for user input.

**Spawn API design principle:** Strongly discourage parameters. Most calls should be `summon_servitor()` with no args — auto-generated names and auto-inferred tasks (transcript_2026-02-02-1650).


### Perseverance Mode vs Chat Mode

Two operating modes for agents:

**Perseverance Mode:** Background operation. When the agent stops, the system auto-prompts it to continue. The agent must explicitly use a tool to get user attention. This is the default for agents working heads-down.

**Chat Mode:** Active conversation. The agent appears in a chat window; the user is notified when the agent pauses or stops. Used when user is actively engaged with that agent.

The user controls which mode each agent is in. Zooming in on an agent brings it to chat mode; "hanging up" returns it to perseverance mode.


### Bubbling

When child agents need user input, they can escalate questions upward through the agent hierarchy. Bubbling is not strictly upward:

- **Upward:** child to parent to grandparent to user

- **Lateral:** sibling agents communicating

- **Direct:** agent to user (with oversight by other agents)

Jake is especially proactive about suggesting the user zoom into specific agents when their attention is needed.


### Agent Naming

Jake assigns each servitor tree a naming theme (LOTR characters, Rick and Morty, Santa's reindeer, Docker-style compound names). This gives users intuitive sense of agent relationships — agents with similar names are from the same task tree.

**Unique names:** Every servitor gets a globally unique name across the entire system. This means you can identify any agent by name alone — no path addressing required for identity.

**Tier depletion:** Themes can have escalating tiers of silliness (e.g., first tier is "Donner, Blitzen, Prancer"; second tier is "Donner 2: The Dominator"). The purpose of tiers is to exhaust less silly names before breaking out sillier ones — it's a depletion mechanism, not just a hierarchy.


### Chat Description

A mutable field visible in the sidebar that summarizes what a chat is about. Both the user and the agent (via tools) can alter it at any time. It includes the original ask plus whatever's current, allowing at-a-glance understanding when switching between agents (transcript_2026-01-27).


### Project-as-Document

The Tavern is fundamentally a document-based Mac app where the "document" is the same as the directory that is the root of the Claude project. Any directory works, like Claude CLI. Full Mac app trappings: File > Open, Open Recent, Dock icon menus, drag-to-open, state restoration on relaunch.


---


## 4. User Flow

This section describes how a user interacts with the system (from transcript_2026-01-19-1144):


### Starting a Fresh Project

1. User opens project directory in the UI

2. For a project with no history, they see only Jake's chat box

3. User describes what they need

4. Jake fires up a servitor to handle it

5. Jake remains free for additional requests


### Working with Agents

- Each task appears as both a todo item AND a chat interface

- Dashboard shows all open tasks; user can drill into any agent chat

- User sees tabs/UX for agents they are actively engaged with

- Notification bubbles appear when agents have questions

- User plays "whack-a-mole" jumping between conversations as needed

- User can create agents directly via `+` button (no dialog, agent waits for first message)


### Zooming In and Out

When user wants to focus on a specific agent:

- System creates a chat box for that agent

- If agent is busy, user sees "cogitating" status while responses stream

- User can steer the agent, interrupt it, or wait

- Agent receives a "calling" message when user zooms in

- Agent receives "hanging up" message when user zooms out

Zoom decisions include: is this chat ephemeral, kept open, or a todo list candidate?


### Dashboard and Oversight

- Task list can surface subtrees based on user's preferred oversight level

- Some agents may be heads down and busy (do not appear in chat interface)

- Jake is always aware of: hibernating agents, unfinished work, backlogs

- User can jump in anywhere they want

- System surfaces high-quality interactions while sparing tedious approvals


### Completing Work

- Servitors expire or go into hibernation when tasks complete

- Jake ensures someone handles open loops

- Dashboard reflects completed vs in-progress vs pending work


### Multi-Window Support

- Each open project = separate window

- Multiple projects can be open simultaneously

- Welcome window shows recent projects ("The Regulars")

- Cmd+O opens the welcome screen

- Windows restore on app restart


---


## 5. Architecture Notes


### Tech Stack

- **Agent runtime:** ClodKit v1.0.0 (renamed from ClodeMonster, migrated from local fork 2026-02-01)

- **Framework:** Swift 6, SwiftUI

- **Platform:** macOS 26+ (Tahoe) — target only the most recent release, no backwards compatibility

- **Build system:** XcodeGen + redo

- **Testing:** 574 Grade 1+2 tests + 32 Grade 3 integration tests


### SDK Migration History

1. **Local fork** (Jan 18 – Feb 1): Protocol-based `ClaudeCode` with `runSinglePrompt()`, dependency injection, `ClaudeCodeResult` enum
2. **ClodeMonster** (Feb 1 – Feb 7): Static function API `ClaudeCode.query()`, lost DI, `ClaudeQuery` AsyncSequence
3. **ClodKit v1.0.0** (Feb 7+): Clean rename `ClaudeCode → Clod`, `import ClodKit`, same API

**Testing implication:** Without dependency injection in the static SDK, the `AgentMessenger` protocol was extracted to restore testability. `LiveMessenger` wraps `Clod.query()` for production; `MockMessenger` provides canned responses for tests (ADR-003).


### Architecture Shapes (ADR-001)

Selected architecture (from architecture exploration with 49 proposals across 16 shapes):

| Shape | Role |
|-------|------|
| E: Shared Workspace | Doc store as blackboard — if it's not in a file, it doesn't exist |
| D: Supervisor Tree | Agent hierarchy with lifecycle, Erlang-style |
| A: Reactive Streams | UI updates, with batching at 60fps |
| A: Message Bus | Agent-to-agent messaging over shared workspace |
| I: Plugin | Closed set of agent types and spawners (registered at startup) |
| C: Layer | Basic layering for testability |

**Note:** The Sidecar shape (L) was originally selected but removed during gap remediation (transcript_2026-02-08). Agents use async/await for I/O instead of separate sidecar actors — `await` suspends without blocking, keeping the cooperative thread pool available.


### Layer Structure

```
UI Layer (thin, dumb)           ← just layout + gestures + bindings
ViewModel Layer                 ← all UX logic (@MainActor)
Application Layer               ← TavernCoordinator, ServitorSpawner
Agent Layer                     ← Jake, Servitor
Domain Layer                    ← Commitment, Assignment
Infrastructure Layer            ← DocStore, SessionStore, ClodKit SDK
```

**Key principle:** Thin UI / Fat ViewModel. 90%+ of UX workflows should be testable via ViewModel unit tests without touching SwiftUI.


### Component Ownership Chain

Per-project, the ownership chain is (transcript_2026-01-25-0108):

```
ProjectManager.shared (singleton)
    └── openProjects: [TavernProject]
            ├── TavernProject (~/project-a/)
            │       ├── ClaudeCode instance (1)
            │       └── TavernCoordinator (1)
            │               ├── Jake (1)
            │               ├── ServitorSpawner (1)
            │               │       ├── AgentRegistry (1)
            │               │       └── NameGenerator (1)
            │               ├── AgentListViewModel (1)
            │               └── ChatViewModel cache (0..*)
            │
            └── TavernProject (~/project-b/)
                    └── ... (same structure, fully isolated)
```

Each open project gets its own fresh stack. The only singleton is `ProjectManager`; everything else is per-project.


### Communication Patterns

- Agents can communicate upward (to parents), laterally (to siblings), or directly to user

- Messages bubble up through hierarchy unless agent has permission for direct contact

- Parent agents provide oversight for child-to-user communication

- Jake coordinates across all task trees


### Concurrency Model

- **Global semaphore** for concurrent Anthropic calls (max ~10)

- **`@MainActor`** on all ViewModels

- **Serial `DispatchQueue`s** protect mutable state within each agent type (Jake, Servitor, AgentRegistry, NameGenerator, CommitmentList, DocStore)

- **Async/await for I/O** — agents call `messenger.query()` directly; `await` suspends without blocking the cooperative thread pool

- **Never block the cooperative thread pool** — no `Thread.sleep`, `DispatchSemaphore.wait`, or sync file I/O


### Session Management

- Session persistence uses UserDefaults (machine-local), keyed by project path

- Agent persistence uses UserDefaults (`PersistedAgent` type with id, name, sessionId, chatDescription)

- Session history rehydration reads from Claude's native JSONL files

- **Session lifecycle:** Local JSONL file for display (read-only), server-side state for resume. A session can be "displayable but not resumable" if server-side state expires. Archives preserve local forensics but cannot resurrect server-side sessions.


---


## 6. Sandbox and Isolation


### Preflight Checks

Every agent gets spawn-time verification before starting:

- Sandbox configured correctly

- Access to required resources

- No permissions prompts expected

- External accounts (AWS, etc.) authenticated and working

**Failure behavior:** Agent does not start; parent is notified with reason. No degraded mode — it's pass/fail.


### Five Sandbox Primitives

Mix and match per child agent. Parent picks settings at spawn.

1. **Changeset** — Overlay filesystem on project root. All writes go to the overlay. The changeset is the diff between original and overlay. Protects original content; another agent can review the changeset independently.

2. **Platform** — Where the agent program runs: Mac, container, cloud, or hybrid.

3. **Isolation** — VMs, containers, OS-level sandboxes. Agent can trash everything and be reaped/restarted.

4. **Outputs** — Network access control. What can the agent reach?

5. **Software** — OS choice: macOS, Linux, FreeBSD, etc.


---


## 7. Core Systems


### Document Store (FOUNDATION)

The memory backbone of the entire system.

**Storage:** Markdown files on disk with jerry-rigged structured data enforcement (to start). Namespaced by document type.

**Multi-purpose:**

- Document storage (specs, PRDs, notes)

- Messaging system (with supporting daemons)

- Work queues (drone dispatch — when item appears, drone fires immediately)

**Key principle:** If it's not in a file, it doesn't exist. The doc store is the blackboard. Agents communicate primarily through shared state in files.


### Document Pipeline (transcript_2026-02-07)

Every document belongs to exactly one pipeline stage. Documents flow forward only.

```
0-transcripts → 1-prd → 2-spec → 3-adr → [code] → [tests] → 4-docs
```

| Stage | Location | Contents |
|-------|----------|----------|
| 0 | `docs/0-transcripts/` | Interview transcripts, reader syntheses, vocabulary, notes |
| 1 | `docs/1-prd/` | Product requirements |
| 2 | `docs/2-spec/` | Testable, traceable specs (18 numbered modules, §000–§017) |
| 3 | `docs/3-adr/` | Architecture Decision Records |
| 4–6 | `Tavern/` | Code, tests, built application |
| 7 | `docs/4-docs/` | Post-implementation documentation |

**Key decisions:**

- No "reference" or "planning" buckets — everything belongs to exactly one stage

- Plans are ephemeral OODA loop artifacts (stage 0), not permanent

- Verification possible at every stage boundary (each stage checkable against its upstream)


### Spec Enumeration & Content Addressing (transcript_2026-02-12)

Specs use a stable `§DOC.SECTION.SUBSECTION` addressing scheme:

- 18 modules numbered §000–§017 (000 = index, 001 = introduction, 002–017 = topical modules)

- **Append-only:** Once a number is assigned, it follows the content for its lifetime

- **Cross-referencing:** Enables concise references like `§4.2.5` instead of duplicating content

- **Sub-file splitting:** Converting a file into a directory with `_index.md` preserves addresses

- **Deduplication:** 27 opportunities identified, 12 major concepts restated across 3-4 files each. Each concept gets a canonical home; other references become `See §X.Y.Z`.


### Property-Based Spec Methodology (transcript_2026-02-10)

Specs are framed as testable properties ("whenever X, then Y") rather than procedural workflows ("first A, then B, then C").

**Four-gap framework** for converting procedural specs to properties:

1. **Prose procedural, assertion has the property** → Promote the property to primary framing

2. **Section 3 flowcharts** → Replace with property tables or state invariants

3. **"What must hold" mixed with "how to implement"** → Separate spec from implementation

4. **Example workflows conflated with specs** → Distinguish illustrative from prescriptive

**Two types of diagrams:** State machine diagrams ARE property specifications. Illustrative examples (like Gang of Experts workflow) show what the system enables, not how it works internally. Both belong in specs, with different purposes.


### Session Storage Layers

Three distinct storage locations:

1. **ClodKit SDK** — conversation history, sessions (in `~/.claude/projects/`)

2. **`.tavern/` in project** — shareable config, templates, agent definitions (version-controllable)

3. **UserDefaults/iCloud** — personal state, session IDs, window positions, persisted agent list (not shared)


### Workflow Engine

Workflow = state machine. The engine helps agents work through step by step.

**Responsibilities:**

- Track and enforce workflow progress

- Manage workflow templates

- Surface open loops and incomplete steps

- Show status for long-running workflows


### Starter Workflows

Pre-configured templates users can modify:

- **Rule of 5:** Five agent passes over a single output from initial prompt (multi-pass refinement)

- **Verification layers:** Progressive gates — linting, then code structure, then architecture, then performance, etc.


---


## 8. UI Concepts


### Dynamic View Architecture

The view layer isn't a fixed hierarchy — it's a composable surface that can be reshaped by both the user AND the agents.

**View System:**

- Composable, not fixed

- User AND agents can modify layout

- Tiles within windows, windows as macOS-level escape hatch

- Granular primitives (chat components can be split: thinking, tools, messages)

**View Modes, Not Routing:**

- Response stream (thinking, tools, text) stays in one place

- Different view modes present same data differently — like Finder's list/icon/column views

- Multiple tiles can show different view modes of the same agent

**Dead Agents Leave Bodies:**

- Tile persists showing final state for review/debugging

- Manual cleanup initially, sophisticated reaping later


### Resource Panel (transcript_2026-02-07)

Right-side panel for viewing project resources, turning the Tavern from a chat app toward a development environment.

**Layout:** HSplitView wrapping ChatView + ResourcePanelView inside the NavigationSplitView detail pane. The resource panel is supplementary to chat, not a peer — it's a toggleable inspector, not a third column.

**v1 scope:**

- File tree browser (lazy, one level at a time for performance)

- Read-only file viewer with line numbers (monospace)

- Binary detection, file size cap (>1MB)

- Filtering: skip .git, .build, .swiftpm, node_modules, DerivedData, .DS_Store

**Deferred:** Syntax highlighting (v1.1), file editing, git status, file search, diff viewer, tabs


### Content Block Rendering

Claude's responses include a `content` array with typed blocks:

- `text` — plain text content

- `tool_use` — tool invocation (name, input parameters as JSON)

- `tool_result` — result from tool (content, isError flag)

- `thinking` — Claude's thinking process

- `web_search_result` — web search output

Each block type has its own visual style in the UI. Message rendering uses extracted components: `MessageRowView`, `CollapsibleBlockView`, `CodeBlockView`, `DiffView` (transcript_2026-02-08).


### Persistence

**Two types:**

- Session restore — automatic, restore what was open on quit

- Saved layouts — named templates (abstract structure) AND concrete snapshots (specific agents, specific state)


### Agent Layout Tools

**Two tool categories with separate permissions:**

- Suggestions — "you might want a tile for Gang B" — user places it, can auto-reject

- Mutations — agent reads layout, modifies directly — requires permission


---


## 9. Agent Communication


### MCP Tools (Current Design)

Jake's interface to the Slop Squad uses native MCP tools registered via `TavernMCPServer`:

- `summon_servitor(task: String?, name: String?)` — Spawns a servitor. Parameters are deliberately optional to discourage Jake from over-specifying.

- `dismiss_servitor(id: UUID)` — Removes a servitor.

Both tools use callbacks (`onSummon`, `onDismiss`) for UI updates from within the MCP handler context.

**Phase 1 scope** (current): summon + dismiss only. **Deferred:** message forwarding, resummon (bringing back dismissed servitors), capability distribution.


### Lateral Collaboration

Messaging is not just for bubbling up. Agents can message each other to collaborate on work.


### Surfacing Questions (flexible modes)

Parent agent chooses approach for handling child questions:

- **Close collaboration:** Chat window pops up with notification

- **Overseer mode:** Periodic summary of outstanding questions


---


## 10. Design Principles


### Informative Error Principle

Error messages shown to users must be specific and actionable, not just "something went wrong." Map every error case to a meaningful message at design time.


### Sum Type Error Design

Use GADTs/sum types to enumerate all failure modes upfront. This forces comprehensive handling at design time rather than as an afterthought.


### Instrumentation Principle

Debug builds must be instrumented thoroughly enough that logs alone can narrow down issues without user explanation or screenshots.

**Logging categories:** `agents`, `chat`, `coordination`, `claude`, `window`, `resources`, `permissions`, `commands`

**Subsystem:** `com.tavern.spillway`


### Testing Principles (transcript_2026-01-27)

Five principles established after a mortal agent session history bug revealed systematic test gaps:

1. **Parallel Code Path Testing** — When code has multiple paths to the same outcome, tests must cover ALL paths.

2. **Feature Toggle Coverage** — When tests disable a feature (`loadHistory: false`), there MUST be other tests that exercise that feature enabled.

3. **User Journey Integration Tests** — Test end-to-end paths users actually take.

4. **Symmetry Assertions** — When multiple APIs should behave consistently, add explicit tests that assert symmetry.

5. **New Entity = New Test Coverage** — New entity types need equivalent test coverage to existing types.


### Testing Grade System (ADR-002, transcript_2026-02-08)

| Grade | What | When to Run |
|-------|------|-------------|
| **1** | Property/unit tests, no mocks | Every change |
| **2** | Unit tests with mocks | Every change |
| **3** | Integration with real Claude (headless) | Once per unit of work |
| **4** | XCUITest (steals focus) | When user isn't active |
| **5** | Stress/product testing | Pre-release |

Grade 3 tests are the **canonical source of truth**. Grade 2 mocks mirror their assertions but can never be more correct than the real thing. Grade 4 XCUITests never mock — they validate actual user experience.


### File Organization Principles (transcript_2026-02-09)

**Anti-pattern:** "Protocol + Production impl + Mock impl + Data types + Utilities" in a single file.

**Fix:** Protocol and data types in one file, each implementation in its own file, mocks in `Testing/`.

**Healthy co-location:** Small enum companions to their primary type (<20 lines, no independent consumers) stay together. Private SwiftUI helper views always co-locate with their parent view.


### Perception-Bounded Performance

"Fast" is not measured in milliseconds but in user perception. The app must remain responsive under all conditions.


### Swarm Execution Methodology (transcripts_2026-02-08)

Parallel agent coordination pattern established across two major swarms:

1. **SWARM.md as execution spec** — Self-contained document at project root with team structure, merge order, test gates, self-destruct on completion

2. **Plan mode gate** — Agent proposes orchestration plan before executing

3. **Grade 3 merge gate** — Each agent runs Grade 3 before merging; coordinator runs Grade 3 after merging; but never during regular dev cycles (finite API resource)

4. **Grade 4 hold** — Wait for user signal at end (XCUITests steal focus)

5. **Model selection** — opus for complex/agent-layer work, sonnet for standard tasks, haiku for docs-only

6. **Merge order** — Most isolated worktree first, most interconnected last


---


## 11. Open Questions

These questions were flagged during discovery for later resolution.


### ?1 — Worktree/Git Assumptions [RESOLVED]

**Resolution:** Do not use git worktrees for agent isolation. Use overlay filesystems orthogonal to git. Changesets work across multiple repos.


### ?2 — Deterministic Shell Meaning [DEFERRED]

What does "deterministic shell" mean concretely? Possibly a full workflow DSL or state machine.


### ?3 — Self Improvement Definition [DEFERRED]

What does "self improvement" mean? Options range from better logging to ML-based prompt optimization to evolutionary workflow design.


### ?4 — Agent "Done" Assertion [PARTIALLY RESOLVED]

**Partial resolution:** `CommitmentVerifier` runs shell assertions against agent claims. `ShellAssertionRunner` replaced the mock with real `Process` execution using `terminationHandler` (non-blocking). Done signal detection: agent response containing `DONE` or `COMPLETED` triggers verification.

**Remaining:** Full verification workflow across agent hierarchies.


### ?5 — Bubbling Up Process [DEFERRED]

Exactly how does bubbling work? Does child ask parent who decides to escalate? Can messages skip levels? Is there prioritization?


### ?6 — Perseverance Prompts and Agent Lifecycle [DEFERRED]

What exactly is a perseverance prompt? What are the lifecycle states of an agent? What triggers transitions?


### ?7 — User Consent for New Chats [DEFERRED]

What does "100% clear they're OK with it" mean concretely? User preference settings? Contextual inference? Per-agent consent?


### ?8 — Sandboxing for Safety [PARTIALLY RESOLVED]

**Partial resolution:** Five sandbox primitives defined (Changeset, Platform, Isolation, Outputs, Software).

**Remaining:** Specific configurations for different scenarios, trust hierarchy details.


### ?9 — UI Stream Separation [PARTIALLY RESOLVED]

**Partial resolution:** View modes instead of routing. Same data, different presentations. Content block rendering implemented with extracted components.

**Remaining:** Full composable tile system.


### ?19 — Work Queues [PARTIALLY ADDRESSED]

Work queues live in the document store. Drones fire when items appear.

**Remaining:** Full specification of queue mechanics, priorities, dependencies.


---


## 12. Vocabulary Decisions


### Cogitation Verbs

The system uses "cogitation verbs" to describe agent processing states (displayed while agent is working). The vocabulary draws from Jewish cultural and linguistic traditions.

**Scope (711 entries):** Yiddish, Hebrew, Ladino, Judeo-Arabic, Talmudic Aramaic, Kabbalistic terminology, and terms from diaspora communities including Ethiopian, Yemeni, Bukharan, Mountain Jews, Karaite, and modern denominational movements.

See `vocab_cogitation-verbs_2026-01-19-1144.md` for the full list.


### Agent Naming Themes

Jake assigns naming themes to agent trees. See `vocab_naming-themes_2026-01-19-1144.md` for details.


### Agent Terminology

| Technical Name | Jake's Voice | Meaning |
|----------------|-------------|---------|
| Servitor | "The Regulars" | Worker agents spawned by Jake |
| ServitorSpawner | — | Factory for creating/dismissing servitors |
| summon | "Summoning" | Creating a servitor |
| dismiss | — | Removing a servitor |
| (all servitors) | "Slop Squad" | The whole team collectively |

**Principle:** Technical documentation uses plain names. Jake's vocabulary is presentation layer only and does not appear in architecture or design documents.


### Jake Character Foundation (transcript_2026-01-18)

Established in the inception session before any technical design:

- **Spillway Principle:** Jokes work once, then become "used" and can't be passed off as new. "Showroom floor models" are used jokes Jake resells at a discount.

- **Jake-isms:** Permanent character vocabulary (not discrete jokes — persistent framing patterns)

- **Name Translation Layer:** Jake uses weird names, other agents use standard names, human learns by exposure (no one explains it)

- **Unsettled Feeling:** User experiences accomplishment + vague unease = "you got a jake job done." Never advertise this — user discovers it.

- **Cast of Characters:** Diverse unattended children at the Tavern with cultural naming conventions (Hispanic, Jewish, Korean, Nigerian, Vietnamese, etc.)


---


## 13. Conversation Chronicle

This section provides a chronological index of when topics were discussed. Use it to trace back to original discussions.


### Session 0 — Project Inception (2026-01-18)

**File:** `transcript_2026-01-18-inception.md`

| Time | Topic | Notes |
|------|-------|-------|
| 04:15 | Jake's voice established | Carnival barker energy, work is flawless, voice is theater |
| 04:15 | Spillway Principle | Joke lifecycle management (new → used) |
| 04:15 | Name translation layer | Jake's weird names vs standard agent names |
| 16:53 | TAP.CLAUDE.md | Homebrew tap variant — infrastructure competent, packages unwarranted |
| 18:46 | Joke management system | New Pile, Used Pile, Showroom Floor Models |
| 18:46 | Jake-isms | Permanent character vocabulary vs one-time jokes |
| 19:02 | README.md | Pure theater, no competence claims, comedy pacing |
| 19:10 | Cast of characters | Diverse unattended children with cultural naming conventions |


### Session 1 — Process Establishment (2026-01-19 09:06)

**File:** `transcript_2026-01-19-0906.md`

| Time | Topic | Notes |
|------|-------|-------|
| 09:06 | Process meta-setup | Two input sources established: verbal + initial_notes.md |
| 09:14 | Transcript format | Notation system: [U], [C], [T], [S] tags |


### Session 1 — Problem Statement (2026-01-19 10:26)

**File:** `transcript_2026-01-19-1026.md`

| Time | Topic | Notes |
|------|-------|-------|
| 10:26 | 14 pain points listed | Attention, tooling, coordination, workflow, visibility |
| 10:31 | Open questions system | [?] notation, verbose context requirement |


### Session 1 — User Flow (2026-01-19 10:40-12:00)

**File:** `transcript_2026-01-19-1144.md`

| Time | Topic | Notes |
|------|-------|-------|
| 10:40 | Core user flow | Jake as entry point, mortal agent spawning |
| 10:40 | 5 task modes, bubbling, perseverance/chat mode | Core concepts |
| 10:40 | Agent naming themes, cogitation verbs | Vocabulary foundations |
| 11:57 | Tech stack | Claude Agent SDK, Swift/SwiftUI |


### Session 1 — /conceive Command (2026-01-19 14:50)

**File:** `transcript_2026-01-19-1450-conceive-command.md`

| Time | Topic | Notes |
|------|-------|-------|
| 14:50 | /conceive slash command | "conceive" = generative, bringing something into existence |


### Sessions 2-8 — Implementation Foundations (2026-01-20 to 2026-01-22)

**Files:** transcripts_2026-01-20 through 2026-01-22

| Date | Topic | Notes |
|------|-------|-------|
| 01-20 | XcodeGen, build system | project.yml, redo scripts |
| 01-21 | Design principles | Informative Error, Sum Type Error, Instrumentation, Autonomous Testing |
| 01-21 | Performance requirements | Perception-bounded performance, stress testing |
| 01-21 | Dynamic view architecture | Composable views, Erlang-style depth, view modes |
| 01-22 | Document-based architecture | Project-as-document, three storage layers, multi-window |
| 01-22 | View architecture deep dive | ViewModel rationale, agent layout tools, component-based chat |
| 01-22 | SDK fix, content blocks | Local SDK fork, MessageType enum, spawn UI |
| 01-22 | Jake's politics | Nazi bar story, absurdist deflection, Jewish identity |
| 01-22 | Session rehydration | Path encoding, JSON-in-JSON, integration tests |


### Session 14 — Headless Testing (2026-01-23)

**File:** `transcript_2026-01-23-headless-testing.md`

| Time | Topic | Notes |
|------|-------|-------|
| — | End-to-end over stubs | Stubs test parser, integration tests test reality |


### Sessions 15-18 — Architecture & Infrastructure (2026-01-24)

**Files:** transcripts_2026-01-24

| Date | Topic | Notes |
|------|-------|-------|
| 01-24 | Architecture exploration | 49 proposals, 16 shapes, compatibility matrix |
| 01-24 | Shape selection (ADR-001) | E+D+A+I+C+L selected |
| 01-24 | Async primitive strategy | AsyncStream long-term, Combine bridge at ViewModel |
| 01-24 | Window restoration | .task(id:) pattern, GUI instrumentation guide |


### Sessions 19-22 — Agent System (2026-01-25 to 2026-01-28)

**Files:** transcripts_2026-01-25 through 2026-01-28

| Date | Topic | Notes |
|------|-------|-------|
| 01-25 | Agent registry architecture | 1:1 chain justified, only ProjectManager is singleton |
| 01-25 | Transcript audit methodology | Parallel rewind agents, one-transcript-per-agent rule |
| 01-27 | Testing principles | 5 principles from session history bug analysis |
| 01-27 | Two-mode spawn, platform policy | User-spawn waits, Jake-spawn works; macOS 26+ only |
| 01-28 | Jake spawn tool | JakeToolHandler protocol, continuation loop, two-level orchestration |


### Session 23 — SDK Migration (2026-02-01)

**File:** `transcript_2026-02-01-sdk-migration-and-session-forensics.md`

| Time | Topic | Notes |
|------|-------|-------|
| — | ClodeMonster migration | Protocol-based → static function API |
| — | Session lifecycle model | Local state vs server state independence |


### Sessions 24-25 — Audit Infrastructure (2026-02-02 to 2026-02-05)

**Files:** transcripts_2026-02-02-0657, 2026-02-05

| Date | Topic | Notes |
|------|-------|-------|
| 02-02 | Transcript audit system | Three-phase process, META transcription |
| 02-05 | Worktree-aware audit | Session dedup, user completeness principle |


### Session 26 — Servitor Naming & MCP Tools (2026-02-02 16:50)

**File:** `transcript_2026-02-02-1650-servitor-naming-and-mcp-tools.md`

| Time | Topic | Notes |
|------|-------|-------|
| 16:50 | Servitor naming decision | MortalAgent → Servitor; two-level terminology |
| 16:50 | MCP tool transition | JSON envelope → native summon_servitor/dismiss_servitor tools |
| 16:50 | Phase 1 scope | Summon + dismiss only; messaging/resummon deferred |
| 16:50 | Spawn API principle | Strongly discourage parameters; auto-generated names |


### Sessions 27-28 — Backlog & JSON Cleanup (2026-02-06)

**Files:** transcripts_2026-02-06

| Date | Topic | Notes |
|------|-------|-------|
| 02-06 | Backlog mining | 46 beads from transcripts/PRD, organized under `azu` epic |
| 02-06 | JSON wrapper removed | parseJakeMessage() deleted, Jake responses now plain text |
| 02-06 | Resource panel exploration | Initial concept, three layout approaches identified |


### Sessions 29-32 — Spec Pipeline & V1 Planning (2026-02-07)

**Files:** transcripts_2026-02-07

| Date | Topic | Notes |
|------|-------|-------|
| 02-07 | Formal spec pipeline | Numbered directories 0-4, 16 modules, verification at every boundary |
| 02-07 | V1 chat parity plan | 9 epics, 43 subtasks, 5 can start immediately |
| 02-07 | Resource panel ideation | HSplitView layout, per-window scope, lazy scanning |
| 02-07 | Resource panel implementation | 11 files, 23 tests, wrong-worktree incident, ClodKit rename |


### Sessions 33-36 — Autonomous Testing & Swarm Execution (2026-02-08)

**Files:** transcripts_2026-02-08

| Date | Topic | Notes |
|------|-------|-------|
| 02-08 | Autonomous testing infrastructure | Grades 1-5, MockAgent, AgentMessenger, ViewInspector, XCUITest, ADRs 002-005 |
| 02-08 | Swarm prompt | Adapted team coordinator from ClodKit, SWARM.md created |
| 02-08 | Swarm execution | 3 phases, 10 agents, 76 beads, 211→526 tests |
| 02-08 | Gap remediation swarm | 12 gaps, 8 worktrees, 526→574 tests |


### Session 37 — Multi-Type File Audit (2026-02-09)

**File:** `transcript_2026-02-09-multi-type-file-audit.md`

| Time | Topic | Notes |
|------|-------|-------|
| — | File organization audit | 15 multi-type files, 3 split candidates, 12 justified |
| — | Anti-pattern identified | Protocol+Impl+Mock+Types in one file |
| — | Three files split | AgentMessenger→3, CommitmentVerifier→4, TavernApp→5 |


### Session 38 — Property-Based Spec Reframing (2026-02-10)

**File:** `transcript_2026-02-10-property-based-spec-reframing.md`

| Time | Topic | Notes |
|------|-------|-------|
| — | Property-based methodology | Properties ("whenever X, then Y") over workflows ("first A, then B") |
| — | Four-gap framework | Promote properties, replace flowcharts, separate spec from impl, distinguish illustrative from prescriptive |
| — | Two types of diagrams | State machines = properties; example workflows = illustrations |
| — | 16 specs rewritten | All converted to property-first structure |


### Session 39 — Spec Enumeration (2026-02-12)

**File:** `transcript_2026-02-12-spec-enumeration.md`

| Time | Topic | Notes |
|------|-------|-------|
| — | §DOC.SECTION.SUBSECTION addressing | Stable, append-only content addressing for specs |
| — | 18 modules numbered §000-§017 | 000=index, 001=intro, 002-017=topical |
| — | Deduplication strategy | 27 opportunities, 12 major concepts get canonical homes |
| — | Document ordering | Rules → Architecture → Agents → Infrastructure → Presentation → Operations → Scoping |


---


## 14. Key Decision Points

Major decisions and their locations:

| Decision | Location | Summary |
|----------|----------|---------|
| Jake as daemon | transcript_2026-01-19-1144 | Always running, spawns servitors |
| Servitor naming | transcript_2026-02-02-1650 | MortalAgent → Servitor; "The Regulars" in Jake's voice |
| MCP tools replace JSON envelope | transcript_2026-02-02-1650 | summon_servitor/dismiss_servitor via TavernMCPServer |
| Phase 1 MCP scope | transcript_2026-02-02-1650 | Summon + dismiss only; messaging/resummon deferred |
| Perseverance mode | transcript_2026-01-19-1144 | Auto-continue, no user notification |
| Chat mode | transcript_2026-01-19-1144 | Active conversation, user notified |
| Bubbling is multi-directional | transcript_2026-01-19-1144 | Upward, lateral, and direct-to-user |
| Tech stack: Swift/SwiftUI | transcript_2026-01-19-1144 | Mac primary, SDK not TUI wrapper |
| Plain names for components | transcript_2026-01-19-1144 | Character names are Jake's voice only |
| Five sandbox primitives | transcript_2026-01-19-1144 | Changeset, Platform, Isolation, Outputs, Software |
| Architecture shapes: E+D+A+I+C | transcript_2026-01-24 | Shared Workspace, Supervisor Tree, Reactive, Plugin, Layer |
| Sidecar removed | transcript_2026-02-08 | Async/await sufficient, no separate I/O actors needed |
| Thin UI / Fat ViewModel | transcript_2026-01-24 | 90%+ of UX testable without SwiftUI |
| AsyncStream long-term | transcript_2026-01-24 | Language features over framework |
| 1:1 component chain justified | transcript_2026-01-25-0108 | Testability and SRP outweigh simplicity concern |
| Two-mode agent spawn | transcript_2026-01-27 | User-spawn waits, Jake-spawn works immediately |
| macOS 26+ only | transcript_2026-01-27 | No backwards compatibility maintenance |
| Testing principles codified | transcript_2026-01-27 | 5 principles from session history bug analysis |
| Testing grade system | transcript_2026-02-08 | 5 grades (ADR-002), Grade 3 is canonical truth |
| AgentMessenger protocol | transcript_2026-02-08 | Restores testability lost in SDK migration (ADR-003) |
| ViewInspector for wiring | transcript_2026-02-08 | SwiftUI view-ViewModel binding tests (ADR-004) |
| XCUITest strategy | transcript_2026-02-08 | E2E never mocks, validates real UX (ADR-005) |
| Two-level orchestration | transcript_2026-01-28 | Tavern agents (persistent) vs Task subagents (ephemeral) |
| SDK migration to ClodKit | transcript_2026-02-01, 2026-02-07 | Static function API, AgentMessenger restores DI |
| Session lifecycle: dual state | transcript_2026-02-01 | Local file for display, server state for resume |
| Document pipeline | transcript_2026-02-07 | 0-transcripts → 1-prd → 2-spec → 3-adr → 4-docs |
| No "reference" bucket | transcript_2026-02-07 | Every document in exactly one pipeline stage |
| Spec enumeration §-addressing | transcript_2026-02-12 | Stable, append-only cross-referencing scheme |
| Property-based specs | transcript_2026-02-10 | Properties over procedures, four-gap framework |
| Resource panel: HSplitView | transcript_2026-02-07 | Supplementary to chat, not a peer column |
| Multi-type file anti-pattern | transcript_2026-02-09 | Protocol+impl+mock+types → split into separate files |
| JSON wrapper removed | transcript_2026-02-06 | Plain text now that MCP tools handle spawning |
| V1 chat parity scope | transcript_2026-02-07 | 9 epics, everything selected ships |
| Swarm methodology | transcript_2026-02-08 | SWARM.md spec, plan mode gate, grade gates, self-destruct |
| User completeness principle | transcript_2026-02-05 | Transcripts must capture ALL user statements |


---


## 15. Source Files

| File | Purpose |
|------|---------|
| `transcript_2026-01-18-inception.md` | Jake's voice, Spillway Principle, joke management, cast of characters |
| `transcript_2026-01-19-0906.md` | Process establishment |
| `transcript_2026-01-19-1026.md` | Problem statement, pain points |
| `transcript_2026-01-19-1144.md` | User flow, architecture, vocabulary |
| `transcript_2026-01-19-1450-conceive-command.md` | /conceive command creation |
| `transcript_2026-01-20-2315.md` | XcodeGen setup, project root |
| `transcript_2026-01-21-0800.md` | Architecture docs, design principles, SDK bug |
| `transcript_2026-01-21-1500.md` | Handoff docs, performance requirements |
| `transcript_2026-01-21-1620.md` | Instrumentation, stress testing |
| `transcript_2026-01-21-2113-performance.md` | Perception-bounded performance |
| `transcript_2026-01-21-2345.md` | Dynamic view architecture |
| `transcript_2026-01-22-0015.md` | Document-based architecture |
| `transcript_2026-01-22-0730-view-architecture.md` | View architecture deep dive |
| `transcript_2026-01-22-1430.md` | SDK fix, content blocks, agent spawn |
| `transcript_2026-01-22-1600.md` | Redo build system |
| `transcript_2026-01-22-1700.md` | Jake's politics |
| `transcript_2026-01-22-2100.md` | Session history content blocks |
| `transcript_2026-01-22-session-rehydration.md` | Full session rehydration implementation |
| `transcript_2026-01-23-headless-testing.md` | Autonomous testing philosophy |
| `transcript_2026-01-24-architecture-exploration.md` | Parallel exploration methodology |
| `transcript_2026-01-24-shape-selection.md` | Architecture decision, ADR-001 |
| `transcript_2026-01-24-async-primitives.md` | Async primitive strategy |
| `transcript_2026-01-24-window-restoration.md` | Multi-window, app icon, GUI instrumentation |
| `transcript_2026-01-25-transcript-audit.md` | Parallel transcript audit methodology |
| `transcript_2026-01-25-0108-agent-registry-architecture.md` | Agent registry analysis, 1:1 relationships |
| `transcript_2026-01-27-testing-principles.md` | Two-mode spawn, testing principles, platform policy |
| `transcript_2026-01-28-jake-spawn-tool.md` | Jake tool handler, spawn tool, two-level orchestration |
| `transcript_2026-02-01-sdk-migration-and-session-forensics.md` | ClodeMonster SDK migration, session lifecycle |
| `transcript_2026-02-02-0657-transcript-audit-system.md` | Audit system execution, design vs transcription sessions |
| `transcript_2026-02-02-1650-servitor-naming-and-mcp-tools.md` | Servitor naming, MCP tool transition, phase 1 scope |
| `transcript_2026-02-05-worktree-aware-audit.md` | Worktree-aware session discovery, user completeness |
| `transcript_2026-02-06-backlog-mining.md` | 46-bead backlog extraction, beads+worktree sync friction |
| `transcript_2026-02-06-json-unwrapped.md` | JSON response wrapper removed, plain text responses |
| `transcript_2026-02-06-resource-panel-exploration.md` | Initial resource panel concept, 3 layout approaches |
| `transcript_2026-02-07-formal-spec-pipeline.md` | Document pipeline, 16 spec modules, verification strategy |
| `transcript_2026-02-07-v1-chat-parity-plan.md` | 9 epics, 43 subtasks, dependency graph for parallelism |
| `transcript_2026-02-07-resource-panel-ideation.md` | HSplitView layout, lazy scanning, v1 scope |
| `transcript_2026-02-07-resource-panel-implementation.md` | 11 files, 23 tests, wrong-worktree incident, ClodKit rename |
| `transcript_2026-02-08-autonomous-testing-infrastructure.md` | Graded testing (1-5), MockAgent, AgentMessenger, ADRs 002-005 |
| `transcript_2026-02-08-swarm-prompt.md` | Team coordinator prompt, SWARM.md creation |
| `transcript_2026-02-08-swarm-execution.md` | 3-phase swarm, 10 agents, 211→526 tests |
| `transcript_2026-02-08-gap-remediation-swarm.md` | 12 gaps, 8 worktrees, 526→574 tests |
| `transcript_2026-02-09-multi-type-file-audit.md` | Multi-type file anti-pattern, 3 files split |
| `transcript_2026-02-10-property-based-spec-reframing.md` | Property-based specs, four-gap framework |
| `transcript_2026-02-12-spec-enumeration.md` | §-addressing, stable content addressing, deduplication |
| `process_2026-01-19-0906.md` | Open questions, meta-process |
| `vocab_cogitation-verbs_2026-01-19-1144.md` | 711 cogitation verbs |
| `vocab_naming-themes_2026-01-19-1144.md` | Agent naming themes |
| `notes_issues-to-plan-for_2026-01-19-1031.md` | Framework-level concerns |
| `../1-prd/prd_2026-01-19.md` | Product requirements document |
| `../4-docs/project-status.md` | Current feature status |
