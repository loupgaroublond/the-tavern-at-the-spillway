# Transcript: Dynamic View Architecture

**Date:** 2026-01-21 23:45
**Session:** View persistence and composable layout system design


## Context

User asked about ViewModel persistence, which led to a deeper discussion about the view architecture. Current system has a fixed layout (Jake chat + agent list). User envisions something far more fluid.


## Interview


**[U]** When you start with a clean session, there's just Jake until he spawns some agents for you to do things. Then the subagents set up their gangs to get to work, and you need some insight into them.

At first, you might just see three chat windows, but even then, the view might be adjustable somehow. I might want to put two chats side by side. I might want to add widgets to give me other status or stats on the gangs depending on things. I might want to template these views, or even offer the agent access to modify the views so they can help direct me to what I should see.

Then, both gangs get really into it, and then I want to break out a window per gang, where one might be more chatty, and the other just shows me high level all the subagents working in parallel, and status.

I might want some combined dashboard of the two in the main window.

This is gonna be a pretty fluid and dynamic system really.


**[C]** So the view layer isn't a fixed hierarchy — it's a composable surface that can be reshaped by both the user AND the agents. Let me make sure I understand the moving parts:

Questions:
1. View primitives — What are the atomic units? Is a "chat" a primitive, or can a chat be further decomposed (input bar, message list, status indicator as separate widgets)?
2. Agent view permissions — When you say agents can "help direct me to what I should see" — is that suggestions ("hey, you should look at Gang B"), or can they actually mutate the layout (agent spawns a new tile, agent minimizes itself)?
3. Gang hierarchy — Jake spawns agents, those agents spawn gangs. Is it always two levels deep, or can gangs spawn sub-gangs recursively? Does the view system need to handle arbitrary depth?
4. Window vs tile — You mentioned "break out a window per gang." Is a window just a detached tile, or does it have different behavior (separate menubar state, independent persistence)?


**[U]** A chat window can have several components too, because I might want thinking on the side, along with tool activities so I can see the chat more clearly. I might also have some unified chat views for several agents in one, somehow. So not sure what the primitives are yet, but I have a rough idea it's granular.

The agent can have a toolset to mutate the layout, with permission, as with any tool usage. We might have a tool to suggest or recommend something too.

The gangs can get infinitely deep. So maybe in the chatty gang, I pick out some subagent working on a thing, open a fourth window to see that view. The system needs arbitrary depth — think Erlang.

Once it's a window, it's a macOS window. That's the big difference.


**[C]** Erlang-style process trees for agents, and the view system mirrors that structure. The window is the escape hatch from tiles to OS-level separation.

More questions:
1. Unified chat view — When multiple agents are in one view, is that interleaved chronologically ("all messages from Gang B in time order"), or sectioned ("Agent 1's messages, then Agent 2's"), or something else (threaded? grouped by topic?)?
2. Thinking + tools as separate components — These are currently part of the Claude response stream. Are you envisioning pulling them out of the message flow entirely (parallel columns), or collapsible inline (expand to see thinking), or user's choice per-view?
3. Persistence scope — When the app restarts, what's the "root" that gets restored? Is it:
   - The whole tree (Jake + all gangs + all their subagents + all view configurations)
   - Just Jake + top-level agents (gangs rebuild themselves)
   - User chooses what to persist vs ephemeral
4. Layout as data — If agents can mutate layout, the layout must be a data structure they can manipulate. Is this a tree? A flat list of tiles with constraints? Something like a scene graph?


**[U]** I don't have a clear sense how the actual chat messages might work, but I might want to see all the tool usage.

We're gonna get a response stream, and then we have to decide where to put it. There will be different options, like you said. Also choice per view.

Restarts is a good question, because I also want to save views, reopen them later. But I'd go with restore what was open when we quit.

We're gonna have to figure out the right data structure, yes, good question.


*[T] So the response stream is the raw input, and there's a routing/splitting layer that decides what goes where based on the view configuration. This is like a pub/sub or multiplexer pattern — one stream in, many destinations out, filtered by type.*


**[C]** So we have two distinct persistence concepts:
- Session restore — what was open when you quit (automatic)
- Saved layouts — named templates you can recall later ("my debugging view", "my monitoring view")

And the response stream is essentially multiplexed — you receive one stream per agent, but it contains mixed content (thinking, tools, text, maybe more), and the view layer routes each piece to its destination based on view configuration.

Probing the edges:
1. Cross-agent views — If I have a "tool usage" panel showing all tool calls, and two agents are both calling tools, do I see them interleaved? Is there agent-coloring or grouping? Can I filter to "just file operations" or "just bash"?
2. View templates vs layout snapshots — A template might be "2 columns, left is chat, right is tools" — abstract. A snapshot is "Agent 'Rusty' in left column, showing messages 47-89" — concrete. Are these different things, or same mechanism?
3. Agent awareness of views — When an agent mutates the layout, do they know what's currently there? ("I see you have Gang B minimized, want me to expand it?") Or do they just fire mutations blindly?


---


## Emerging Concepts

*(To be filled in as interview progresses)*


### Agent Hierarchy

- Jake at root
- Subagents spawned by Jake
- Gangs spawned by subagents
- Arbitrary depth (Erlang-style process trees)


### View System

- Composable, not fixed
- User AND agents can modify layout
- Tiles within windows, windows as macOS-level escape hatch
- Granular primitives (chat components can be split: thinking, tools, messages)


### Response Stream Routing

- Single stream per agent contains mixed content types
- View layer multiplexes stream to destinations
- Per-view configuration for what goes where


### Persistence

- Session restore: automatic, restore what was open on quit
- Saved layouts: named templates for recall
- Data structure TBD


### Agent Layout Tools

- Mutation tools (with permission, like any tool)
- Suggestion/recommendation tools
- Open question: agent awareness of current view state


---


## Interview (continued)


**[U]** All good options, this is probably a feature we develop later when we have a better idea what it'll need.

I don't get this question.

They have to see the current layout to mutate, unless it's just suggesting to add a tile, and let the user put it somewhere.


**[C]** Let me clarify the templates vs snapshots question:

**Template (abstract):** "Two columns. Left column gets a chat. Right column gets a tools panel." — No specific agent bound, just structure.

**Snapshot (concrete):** "Two columns. Left column has Agent 'Rusty' showing messages 47-89, scrolled to bottom. Right column has tools panel filtered to bash calls." — Specific agent, specific state.

When you "save a view for later," which are you saving? The abstract shape, or the full concrete state? Or both as separate features?

---

And on agent awareness — so there's a spectrum:

1. **Blind suggestion:** "Hey user, you might want a tile for Gang B" — user places it
2. **Aware mutation:** Agent reads current layout, says "I'm adding myself to the right column" — happens automatically (with permission)

Sounds like both could exist. Suggestion is lower friction (no permission needed?), mutation is more powerful but requires permission.


**[U]** There's templates, abstract, and then concrete views, both.

Well, different types of permissions. A user might auto-reject suggestions. They will be different tools, so there's a clear isolating boundary for different permission types.


*[T] So the permission system is tool-granular. "Allow layout mutations" is a different permission than "allow layout suggestions." User can blanket-reject one category while allowing the other. This maps cleanly to the existing tool permission model.*


**[C]** Next question: the Erlang-style agent tree and the view tree — do they mirror each other, or are they independent? If Jake spawns Agent A who spawns Gang B with 5 workers, does the view automatically reflect that hierarchy? Or can I have a flat view that just shows "all 7 agents" regardless of who spawned whom?


**[U]** I might have a tree or flat view, depending on need. I might also have parts of the tree folded or rolled up, but that's a more sophisticated feature for later in dev.


*[T] View structure is independent of agent hierarchy. Can render same agents as tree or flat. Folding/collapsing is a presentation concern, not structural — defer to later.*


**[C]** What about lifecycle? When an agent dies (task complete, dismissed, crashed), what happens to its tiles?


**[U]** Well, if someone dies, there's a body, right?


*[T] Dead agents leave remains — the tile persists showing final state. You can review what happened. The body doesn't vanish. This fits the tavern metaphor and is practically useful for debugging/review.*


**[C]** Can you dismiss the body when you're done with it? Or does it eventually get cleaned up automatically (like a reaper process)?


**[U]** Probably manually at first, but maybe more sophisticated options later.


*[T] Start simple — manual cleanup. Automatic reaping or decay is a future feature.*


**[C]** For the layout data model — for persistence and agent mutation, it needs to be serializable. What's your gut on the shape? Tree? Flat with constraints? Scene graph?


**[U]** Not quite sure, but it's gonna line up with the user interface that seems to fit best. I'm wary of things like binary trees for views, like some tiling window managers do. But besides that, I think that's an area for exploration later.


*[T] Data structure TBD — will emerge from UI needs. Binary tree layouts (like i3/bspwm) explicitly not desired. Keep options open.*


**[C]** Different angle: the response stream routing. You get a stream from Claude with mixed content — thinking, tool calls, text. Who decides the routing rules? Per-view config? Global filter? Agent-specific?


**[U]** It's more like switching between lists and icons in Finder.


*[T] Reframe: it's not routing to different destinations, it's different VIEWS of the same data. Like Finder's list/icon/column views — same files, different presentation. A chat can be rendered as unified stream OR as separated components, but it's the same underlying data.*


**[C]** Does that mean a single agent could have multiple tiles showing different view modes of the same conversation? Like, one tile in unified mode, another in split mode, both live-updating from the same stream?


**[U]** Probably.


*[T] Multiple views of same agent data allowed. This is like having two Finder windows open to the same folder — one in list, one in icons. Both reflect the same truth, different lenses.*


**[C]** Let's talk MVP. What's the smallest useful version that moves toward this vision?


**[U]** The MVP is to have some more architecture design to this, beyond just saying "oh, we have view models." Because the persisted data structures — can they be on non-main threads? If so, how does this interface with everything else? And so on. We need to answer those questions to some extent today. Another is infrastructure around widgets — like, if we organize the directory structure of the sources by component, rather than by type as it is at the moment.


*[T] MVP is architectural, not feature. Two concrete deliverables: (1) Threading model for persisted view state — where does it live, how does it sync to MainActor-bound views? (2) Source organization — move from type-based (Agents/, Chat/, Coordination/) to component-based structure that supports widgets.*


**[C]** For threading, options are: (1) persist from MainActor, write on background; (2) shadow state off-main, sync two copies; (3) truth lives off-main, views observe. Which direction?


**[U]** Probably close to 1, but it's more that besides writing to disk, I'm struggling to come up with other reasons these would be off the main thread.


*[T] YAGNI instinct — don't add threading complexity without clear need. View state on main thread is fine. Only the actual disk I/O needs to be async. Serialize on main, write on background. Keep it simple.*


**[C]** Simple model then: view state is @MainActor, persistence is just async I/O. Now source organization — currently type-based. What would component-based look like?


**[U]** Something like that, yeah — once we have a bunch of these and we need to reorganize the folder structure from what we have today. But for now, we don't need to change much as there's so few files anyways.


*[T] Don't reorganize prematurely. Current type-based structure is fine for current scale. Revisit when widget count justifies component-based organization.*


**[C]** What else needs clarity now? The view data structure — do you need to sketch the protocol for what a "tile" conforms to?


**[U]** Not really. The next topic is the document architecture, for discussion tomorrow.


---


## [S] Synthesis: Dynamic View Architecture


### Core Concepts

**View system is composable, not fixed.** Users and agents can reshape the layout. Tiles within windows, windows as macOS-level escape hatch.

**Agent hierarchy is Erlang-style.** Jake → subagents → gangs → sub-gangs, arbitrary depth. View structure is independent — same agents can render as tree or flat.

**View modes, not routing.** Response stream (thinking, tools, text) stays in one place. Different view modes present same data differently — like Finder's list/icon/column views. Multiple tiles can show different view modes of the same agent.

**Dead agents leave bodies.** Tile persists showing final state for review/debugging. Manual cleanup initially, sophisticated reaping later.


### Persistence Model

**Two types:**
- Session restore — automatic, restore what was open on quit
- Saved layouts — named templates (abstract structure) AND concrete snapshots (specific agents, specific state)


### Agent Layout Tools

**Two tool categories with separate permissions:**
- Suggestions — "you might want a tile for Gang B" — user places it, can auto-reject
- Mutations — agent reads layout, modifies directly — requires permission


### Threading Decision

**View state stays @MainActor.** No reason to complicate with off-main-thread state. Persistence is just async I/O: serialize on main, write on background.


### Deferred Decisions

- View data structure shape (not binary tree, but TBD)
- Cross-agent filtering (tool type, agent coloring)
- Tree folding/collapsing
- Automatic body cleanup (reaping)
- Component-based source organization (when scale demands)


### Next Topic

Document architecture — tomorrow.
