# Transcript: Document-Based Architecture

**Date:** 2026-01-22 00:15
**Session:** Document architecture — project root as document


## Context

Current state: Jake works from `/` (app's cwd). No project selection. The Tavern needs to be fundamentally built as a document-based app where the "document" is a Claude project directory.


## Interview


**[U]** The Tavern is fundamentally a document-based app, where the "document" is the same as the directory that is the root of the Claude project. We need to fundamentally build this app around this design. And actually, once we're done talking out this feature, we need to implement the beginnings of that, so Jake isn't just Claude on root `/`.


**[C]** So the Tavern becomes like Xcode or VSCode — you open a project directory, and that's your working context. Questions:
1. Multi-document — multiple projects open at once?
2. Project state — stored in project dir (`.tavern/`) or elsewhere keyed by path?
3. Recent projects — standard "Open Recent" or something more Tavern-flavored?


**[U]** Multi-document, yes.

Project state can be both, depending on whether it's iCloud state or something else.

Open recent menu is good, but maybe we Jake it up a bit?


*[T] Multi-window, multi-project. State storage is hybrid — some in-project (shareable, version-controllable), some external (user-specific, synced via iCloud). Recent projects list gets the Jake treatment — "regulars" who keep coming back to the Tavern.*


**[C]** On hybrid storage — in-project for shareable stuff, external/iCloud for personal. What goes where specifically? And Jake-ing up the recent menu — "The Regulars"? Nicknames? Comments on absence?


**[U]** Conversation history is part of the Claude Agent SDK, the Tavern storage though — `.tavern/` is probably things to share, and then iCloud for personal state you don't share.

The Regulars is good, but we can dabble with more creative welcome pages later.


*[T] Three storage layers:
1. Claude SDK handles conversation history (sessions)
2. `.tavern/` in project — shareable config, templates, agent definitions
3. iCloud/external — personal state (window positions, preferences, view layouts?)

Welcome page creativity deferred. Focus on architecture first.*


**[C]** macOS has NSDocument/NSDocumentController for document-based apps — gives you open/save dialogs, recent docs, multiple windows, dirty tracking, autosave. Use that framework or roll custom? Directory-as-document is slightly non-standard.


**[U]** We probably won't be able to straight up use NSDocument for the directory, TBD. But files can. Autosave is a given, because that's how Macs do things. Definitely can have multiple windows into the same document.


*[T] May need custom document controller for directory-as-document. Individual files within project can still use NSDocument. Autosave expected. Multiple windows into same project supported — ties back to the view architecture discussion.*


**[C]** What's the flow when you open a project? And what makes a directory valid — any directory, or must have `.git`, `CLAUDE.md`, etc.?


**[U]** Tavern works anywhere, just like Claude Code. So you got the idea.


*[T] No special requirements for a directory to be a "project." Any directory works. Tavern creates `.tavern/` on first use if needed. Mirrors Claude Code CLI behavior.*


**[C]** Claude CLI has its own project model — `~/.claude/projects/` with settings per path. Does Tavern use it, replace it, or hybrid? And do spawned agents share project scope or get their own?


**[U]** Hybrid. Most agents share project scope unless there's some sophisticated sandboxing, but they have their own sessions/context and just show up as sessions in Claude's projects dir.


*[T] Tavern layers on top of Claude's project system, doesn't replace it. All agents work in same project scope (directory, CLAUDE.md). Each agent = separate Claude session. Sessions appear in ~/.claude/projects/ like normal Claude CLI sessions. Sandboxing is future sophistication.*


**[C]** For implementation — minimal change to get Jake off root `/`: add project path to initializer, pass to SDK, add project selection UI. Right first step?


**[U]** We probably need some adapter classes to wrap around the SDK nominally, at first, so that we can reuse it with Jake and other agents, and then configure it to use a specific cwd. We should embrace the full document design of a Mac app, though, early on, with all the usual trappings.


*[T] Not just "pass a path to Jake" — need proper abstraction. Adapter layer wrapping ClaudeCodeSDK that handles project scope, reusable across all agent types. And commit to full macOS document architecture from the start — don't half-measure it.*


**[C]** Full document design trappings: File > Open/Open Recent/New Window, window title shows project, Dock icon recent projects, Cmd+O/Cmd+N, drag folder onto dock, welcome window, state restoration. Which are must-haves for first pass?


**[U]** Yes.


*[T] All of it. This is a proper Mac app, not a web app in disguise. The document architecture is foundational, not a feature to add later.*


**[C]** Two pieces: SDK adapter layer (wraps ClaudeCodeSDK, configures project root) and document architecture (NSDocumentController or equivalent). For adapter, maybe a TavernSession class that wraps SDK, always scoped to projectRoot. Jake and MortalAgent take TavernSession instead of raw ClaudeCode. Right direction?


**[U]** Maybe. I'm wary of factory classes in general, as convoluted. And we don't want to wear a hair shirt where we need to replicate the same SDK again in another layer. But we definitely need some kind of general pattern to set up the Claude agents correctly, like your proposal, or simpler.


*[T] Keep it thin. Don't wrap for wrapping's sake. Maybe just a configuration + factory function rather than a full wrapper class. The SDK does the work, we just need to configure it consistently.*


**[C]** Simpler options: (A) config struct + factory function, (B) extension on ClaudeCode with static method, (C) Project object owns config and makes agents. Which feels least hair-shirty?


**[U]** Those are all viable options. Let's keep them all in our back pocket and then pick the one that works best as we need it. In all three cases, they're fairly similar — the difference being you have to pass more explicit state into a static constructor method, which is a technical detail more than anything else.


*[T] Don't over-design. All three approaches are equivalent in spirit — "configure ClaudeCode correctly for a project." Pick during implementation based on what fits. The pattern matters, the exact shape doesn't yet.*


**[C]** For document architecture: DocumentGroup (SwiftUI built-in), NSDocumentController subclass (AppKit, more control), or custom from scratch. Given you want full Mac trappings, I'd lean NSDocumentController or custom. DocumentGroup might fight you on directory-as-document.


**[U]** Let's see what we can do with DocumentGroup until we hit limits. Again, keep it simple until it ain't simple anymore.


*[T] Start with SwiftUI's DocumentGroup. Hit the walls, then decide. Don't preemptively reach for AppKit complexity.*


**[C]** Scope for today: DocumentGroup setup, Project model, Jake scoped to project, basic Open flow. Not in scope: saved layouts, `.tavern/`, multiple windows, welcome screen, full state restoration. Right slice?


**[U]** Yeah. I want to open up a Tavern window into this project, for instance, as well as give us the flexibility to create mock projects for testing purposes.


*[T] Concrete acceptance criteria: (1) Can open Tavern pointed at the-tavern-at-the-spillway itself, Jake works there. (2) Tests can create mock project directories and open them. Testability is first-class.*


**[C]** With document-based architecture, does Project become the top-level owner, each open project has its own coordinator? App → Project → TavernCoordinator → Jake. Or different structure?


**[U]** When you say different structure, did you have something specific to suggest or other alternatives worth examining? I think we probably need some kind of central bit too, but that's literally what an App is anyways.


*[T] No alternative needed. The structure is natural: App is the central bit (manages documents), each Project/Document owns its TavernCoordinator, each Coordinator owns its Jake. Standard document-based app hierarchy.*


**[C]** Clean hierarchy: App (via DocumentGroup) → TavernProject (document) → TavernCoordinator → Jake. Ready to synthesize and implement?


**[U]** Yeah. We might have some kind of tavern of taverns at some point, so there would be a TavernCoordinator directly descending from App. But let's burn that bridge when we get there.


*[T] Future possibility: meta-coordinator at App level managing multiple projects as a unified workspace. Deferred. For now, each project is independent.*


---


## [S] Synthesis: Document-Based Architecture


### Core Model

**Tavern is a document-based Mac app.** The "document" is a project directory (any directory, like Claude CLI). Full Mac app trappings: File > Open, Open Recent, Dock icon menus, drag-to-open, state restoration on relaunch.


### Storage Layers

Three distinct storage locations:

1. **Claude SDK** — conversation history, sessions (in `~/.claude/projects/`)
2. **`.tavern/` in project** — shareable config, templates, agent definitions (version-controllable)
3. **iCloud/external** — personal state, window positions, preferences (not shared)


### Architecture

```
App (DocumentGroup)
└── TavernProject (document, owns root URL)
    └── TavernCoordinator
        └── Jake (ClaudeCode scoped to project root)
```

- Each open project = separate document = separate window
- Each project has its own Jake, own agents, own state
- Multiple windows into same project supported
- All agents in a project share the project scope (same working directory, same CLAUDE.md)
- Each agent = separate Claude session (visible in Claude's standard project directory)


### SDK Configuration

Need a pattern to configure ClaudeCode instances consistently for a project. Three equivalent options kept in pocket:
- Config struct + factory function
- Extension with static constructor
- Project object as factory

Pick during implementation based on what fits. Don't over-wrap.


### Implementation Approach

Start with SwiftUI's DocumentGroup. Hit walls, then escalate to NSDocumentController or custom. Keep it simple until it ain't.


### Today's Scope

1. DocumentGroup setup for directory-as-document
2. TavernProject model (root URL, owns coordinator)
3. Jake scoped to project root
4. Basic Open flow

**Acceptance criteria:**
- Can open Tavern into the-tavern-at-the-spillway project, Jake works there
- Tests can create mock project directories

**Not today:**
- `.tavern/` storage
- Saved layouts
- Multiple windows into same project
- Welcome screen / "The Regulars"
- Full state restoration


### Deferred

- Tavern of taverns (meta-coordinator at App level)
- Sophisticated agent sandboxing
- Component-based source reorg


---


## Interview (continued)


**[C]** DocumentGroup is designed for file-based or package documents (directories with extensions like `.tavern-project`), not arbitrary folders. Two paths: (A) Package document model — create `.tavern/` projects, gets DocumentGroup benefits but changes UX. (B) Custom open flow — WindowGroup + NSOpenPanel, any folder works, build recent menu ourselves.


**[U]** We need to do Path B, so folks can adapt existing projects. But we might support Path A down the road depending on the user base's needs.


*[T] Path B confirmed. Any folder works, like Claude CLI. Package documents may come later as an option. Implementation: WindowGroup + NSOpenPanel + manual project tracking.*


**[U]** (During implementation) When this is done, let's adopt Redo, the build system by apenwarr, to wrap around some of these common build actions.


**[U]** Another note is that we can stick to the latest release of macOS for compat and use all the new features. I don't care about people who are running older insecure versions of the OS, and no one is paying us to care (yet).


*[T] Two notes for later: (1) Adopt Redo for build automation. (2) Target latest macOS only — no backward compat burden, can use all new APIs.*


---


## Implementation Complete


**Files created:**
- `Sources/TavernCore/Project/TavernProject.swift` — Project model holding root URL, creates scoped ClaudeCode instances
- `Sources/TavernCore/Project/ProjectManager.swift` — Singleton managing open projects, recent projects list

**Files modified:**
- `Sources/Tavern/TavernApp.swift` — Complete rewrite: welcome screen, project views, NSOpenPanel integration, Open Recent menu

**Result:** User opened a project, Jake correctly used the project's working directory. Document-based architecture foundation is in place.


**Sandbox project created:**

`sandbox/` directory added with:
- `CLAUDE.md` — Project instructions for testing
- `README.md` — Basic readme
- `src/main.swift` — Sample file to play with
- `.git/` — Initialized git repo

This provides a safe place to test the app without risking real projects.


**Dock menu implemented:**

`TavernAppDelegate` added with `applicationDockMenu(_:)` providing:
- Recent projects list (up to 10)
- "Open Project..." option
- Uses `@NSApplicationDelegateAdaptor` to wire up to SwiftUI app


**Still pending:**
- Window title showing project path
- State restoration on relaunch
