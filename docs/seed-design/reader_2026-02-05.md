# The Tavern at the Spillway — System Design Reader

**Date:** 2026-02-05

**Purpose:** This document synthesizes all discovery session transcripts into a standalone explanation of the system design. Read this instead of tailing transcripts.

**Previous reader:** `reader_2026-01-25.md` — This update incorporates 6 additional transcripts from 2026-01-25 through 2026-02-05.


---


## 1. Executive Summary

The Tavern at the Spillway is a multi-agent orchestration framework with a custom macOS user interface. The system manages a swarm of AI agents working on development tasks, with a coordinating "daemon" agent (Jake) that spawns and manages "mortal" task-specific agents.

The core value proposition is solving the attention management problem: when using one AI agent, there is idle time; when using many, the human cannot track them all. This framework provides a dashboard and chat interface that surfaces the right agent conversations at the right time, allowing users to engage productively with multiple agents without being overwhelmed by notifications or missing critical questions.

The system is built on the ClodeMonster NativeClaudeCodeSDK and ships as a macOS application with a GUI-less framework core for potential alternative interfaces.

**Current implementation state:** Jake responds using `.json` format with a swappable tool handler (protocol-based for future SDK migration), two-mode agent spawning (user-spawn waits for input, Jake-spawn works immediately), agent persistence via UserDefaults, session history restoration for both Jake and mortal agents, multi-project support with per-project session persistence, multi-window architecture (welcome window + per-project windows), agent spawning with themed names and UI, content block rendering infrastructure, window restoration on app restart, two-level orchestration model (Tavern agents for tracked work, Task subagents for ephemeral parallelism). 200 tests passing.


---


## 2. Problem Statement

These pain points drove the design (from transcript_1026, 10:26):


**Attention Management:**

- One Claude Code instance means waiting around with low efficiency

- Multiple instances require tracking all of them while engaging with any single one

- More than 5 sessions becomes impossible to manage while also doing focused work

- Permission requests from background agents interrupt focused conversations


**Tooling Gaps:**

- YOLO mode needs a sandbox; the built-in one does not fit; third-party tools make incorrect assumptions about git and worktrees

- IDE integration is janky in the terminal; VSCode plugin has different issues

- No good tool to balance jumping into code yourself vs letting the agent work

- Terminal-based TUIs are hard to manage; everyone settles on tmux-based solutions


**Coordination Problems:**

- Agents run free-for-all; fixes turn into complex pipelines

- Too many agents clobber each other when working on the same things

- Worktree management tools make gross assumptions about repo usage


**Workflow Rigidity:**

- Many workflows require deterministic shells to enforce correct execution; hooks constrain without flexibility

- Many frameworks do not manage "efficiency of quality" and allow agents to burn too many tokens

- Frameworks either have rigid workflows or no workflows at all


**Visibility Gaps:**

- No self-improvement of these systems

- Not enough telemetry to improve; heavy reliance on brute force

- TUI Claude Code smooshes everything together (thinking, tool use, coding, chat) making it unreadable


---


## 3. Core Concepts


### Jake (The Proprietor)

Jake is the top-level coordinating daemon agent. He is always running and manages the entire system. Key characteristics:

- **Daemon lifecycle:** Jake never dies; mortal agents are task-bound

- **Lowest privileges by quantity:** Jake has few direct capabilities but highest authority to spawn and manage other agents

- **First contact:** For a fresh project, the user's first interaction is with Jake

- **Task delegation:** Jake quickly fires up mortal agents to handle work, staying free for the next request

- **Tool handler:** Jake uses a protocol-based `JakeToolHandler` to process structured JSON responses and execute actions (like spawning agents). The handler is swappable — currently `JSONActionHandler` parses `{"message": "...", "spawn": {"assignment": "...", "name": "..."}}`, but the protocol allows future migration to native SDK tools without touching Jake's core logic (transcript_2026-01-28).

Jake has a distinctive voice (used car salesman energy, carnival barker theatrics), but this is presentation layer only. The work is flawless. Full character specification is in `docs/jake-character.md`.

Jake is Jewish (doesn't make it his whole personality, but it's there). This is personal for him. One hard political line: nazis are not tolerated. The Tavern welcomes everyone. Except nazis.


### Mortal Agents

Agents spawned by Jake to complete specific tasks. Their lifecycle is bound to task completion.

**Task Modes** (agents can bounce between these):

- Execute directly

- Delegate to a new child agent

- Plan more first

- Break into pieces and assign

- Unify work from delegated children

Mortal agents can have children, forming a tree structure per user request. Agent hierarchies are Erlang-style — arbitrary depth, no limits.


### Two-Level Orchestration Model

Jake operates a two-level agent system (transcript_2026-01-28):

**Level 1 — Tavern Agents** (via spawn action):

- Full Claude Code sessions with their own context

- Appear in sidebar, persist across sessions

- For substantial, independent work streams

- Created via Jake's JSON spawn action

**Level 2 — Subagents** (via Task tool):

- Internal parallel workers within any agent's session

- Lightweight, ephemeral, don't persist

- For quick parallel tasks within a single work stream

- Any agent (including Jake) can spawn these directly via Task tool

**When to use which:** Spawn Tavern agent for tracked work ("help me build feature X"). Use Task tool for quick internal parallelism ("search these 5 files in parallel").


### Two-Mode Agent Spawning

Agent spawning has two modes depending on who initiates (transcript_2026-01-27):

**User-spawn:** User clicks `+` in toolbar. No dialog — agent is created instantly with a system prompt that tells it to wait for the user's first message. The user types their request into the normal chat UI.

**Jake-spawn:** Jake decides to delegate work. Agent is created with an assignment and a system prompt that tells it to work on the assignment immediately before waiting for user input.


### Perseverance Mode vs Chat Mode

Two operating modes for agents:

**Perseverance Mode:** Background operation. When the agent stops, the system auto-prompts it to continue. The agent must explicitly use a tool to get user attention. This is the default for agents working heads-down.

**Chat Mode:** Active conversation. The agent appears in a chat window; the user is notified when the agent pauses or stops. Used when user is actively engaged with that agent.

The user controls which mode each agent is in. Zooming in on an agent brings it to chat mode; "hanging up" returns it to perseverance mode.


### Bubbling

When child agents need user input, they can escalate questions upward through the agent hierarchy. Bubbling is not strictly upward:

- **Upward:** child to parent to grandparent to user

- **Lateral:** sibling agents communicating

- **Direct:** agent to user (with oversight by other agents)

Jake is especially proactive about suggesting the user zoom into specific agents when their attention is needed.


### Agent Naming

Jake assigns each mortal agent tree a naming theme (LOTR characters, Rick and Morty, Santa's reindeer, Docker-style compound names). This gives users intuitive sense of agent relationships — agents with similar names are from the same task tree.

**Unique names:** Every mortal agent gets a globally unique name across the entire system. This means you can identify any agent by name alone — no path addressing required for identity.

**Tier depletion:** Themes can have escalating tiers of silliness (e.g., first tier is "Donner, Blitzen, Prancer"; second tier is "Donner 2: The Dominator"). The purpose of tiers is to exhaust less silly names before breaking out sillier ones — it's a depletion mechanism, not just a hierarchy.


### Chat Description

A mutable field visible in the sidebar that summarizes what a chat is about. Both the user and the agent (via tools) can alter it at any time. It includes the original ask plus whatever's current, allowing at-a-glance understanding when switching between agents (transcript_2026-01-27).


### Project-as-Document

The Tavern is fundamentally a document-based Mac app where the "document" is the same as the directory that is the root of the Claude project. Any directory works, like Claude CLI. Full Mac app trappings: File > Open, Open Recent, Dock icon menus, drag-to-open, state restoration on relaunch.


---


## 4. User Flow

This section describes how a user interacts with the system (from transcript_1144, 10:40):


### Starting a Fresh Project

1. User opens project directory in the UI

2. For a project with no history, they see only Jake's chat box

3. User describes what they need

4. Jake fires up a mortal agent to handle it

5. Jake remains free for additional requests


### Working with Agents

- Each task appears as both a todo item AND a chat interface

- Dashboard shows all open tasks; user can drill into any agent chat

- User sees tabs/UX for agents they are actively engaged with

- Notification bubbles appear when agents have questions

- User plays "whack-a-mole" jumping between conversations as needed

- User can create agents directly via `+` button (no dialog, agent waits for first message)


### Zooming In and Out

When user wants to focus on a specific agent:

- System creates a chat box for that agent

- If agent is busy, user sees "cogitating" status while responses stream

- User can steer the agent, interrupt it, or wait

- Agent receives a "calling" message when user zooms in

- Agent receives "hanging up" message when user zooms out

Zoom decisions include: is this chat ephemeral, kept open, or a todo list candidate?


### Dashboard and Oversight

- Task list can surface subtrees based on user's preferred oversight level

- Some agents may be heads down and busy (do not appear in chat interface)

- Jake is always aware of: hibernating agents, unfinished work, backlogs

- User can jump in anywhere they want

- System surfaces high-quality interactions while sparing tedious approvals


### Completing Work

- Mortal agents expire or go into hibernation when tasks complete

- Jake ensures someone handles open loops

- Dashboard reflects completed vs in-progress vs pending work


### Multi-Window Support

- Each open project = separate window

- Multiple projects can be open simultaneously

- Welcome window shows recent projects ("The Regulars")

- Cmd+O opens the welcome screen

- Windows restore on app restart


---


## 5. Architecture Notes


### Tech Stack

- **Agent runtime:** ClodeMonster NativeClaudeCodeSDK (migrated from local fork 2026-02-01)

- **Framework:** Swift 6, SwiftUI

- **Platform:** macOS 26+ (Tahoe) — target only the most recent release, no backwards compatibility

- **Build system:** XcodeGen + redo

- **Testing:** 200 unit tests + 8 stress tests


### SDK Migration (2026-02-01)

Migrated from a local ClaudeCodeSDK fork (protocol-based with dependency injection) to ClodeMonster's NativeClaudeCodeSDK (static function API):

| Old SDK (Protocol-based) | New SDK (Static function) |
|--------------------------|---------------------------|
| `ClaudeCode` protocol with `runSinglePrompt()` | `ClaudeCode.query(prompt:options:)` |
| Dependency injection via protocol | No injection point — static function |
| `ClaudeCodeResult` enum (.json/.text/.stream) | `ClaudeQuery` (AsyncSequence of StdoutMessage) |
| `ResultMessage.sessionId` | `query.sessionId` (async property) |
| `ClaudeCodeConfiguration` + `ClaudeCodeOptions` | Unified `QueryOptions` |

**Testing implication:** Without dependency injection, tests that previously mocked Claude responses cannot work the same way. Tests requiring mocking are marked TODO.


### Why Not Wrap Claude Code TUI

- TUI is not conducive to programmatic control

- Requires hooks when we could just send messages directly

- Cannot easily separate different content streams

- The "smooshed together" display problem is inherent to the TUI approach


### Architecture Shapes (ADR-001)

Selected architecture (from architecture exploration with 49 proposals across 16 shapes):

| Shape | Role |
|-------|------|
| E: Shared Workspace | Doc store as blackboard — if it's not in a file, it doesn't exist |
| D: Supervisor Tree | Agent hierarchy with lifecycle, Erlang-style |
| A: Reactive Streams | UI updates, with batching at 60fps |
| A: Message Bus | Agent-to-agent messaging over shared workspace |
| I: Plugin | Closed set of agent types and spawners (registered at startup) |
| C: Layer | Basic layering for testability |
| L: Sidecar | Agent responsiveness while managing children |


### Layer Structure

```
UI Layer (thin, dumb)           ← just layout + gestures + bindings
ViewModel Layer                 ← TileViewModel, PanelViewModel, all UX logic
Application Layer               ← Coordinator, Spawner
Agent Layer                     ← Jake, MortalAgent, Sidecar
Domain Layer                    ← Commitment, Assignment
Infrastructure Layer            ← DocStore, SDK
```

**Key principle:** Thin UI / Fat ViewModel. 90%+ of UX workflows should be testable via ViewModel unit tests without touching SwiftUI.


### Component Ownership Chain

Per-project, the ownership chain is (transcript_2026-01-25-0108):

```
ProjectManager.shared (singleton)
    └── openProjects: [TavernProject]
            ├── TavernProject (~/project-a/)
            │       └── coordinator: TavernCoordinator (1)
            │               └── spawner: AgentSpawner (1)
            │                       └── registry: AgentRegistry (1)
            │
            └── TavernProject (~/project-b/)
                    └── coordinator: TavernCoordinator (2)
                            └── spawner: AgentSpawner (2)
                                    └── registry: AgentRegistry (2)
```

Each open project gets its own fresh stack. Agents in Project A are completely isolated from Project B. The only singleton is `ProjectManager`; everything else is per-project.

**1:1 relationship rationale:** The chain (TavernProject → TavernCoordinator → AgentSpawner → AgentRegistry) has 1:1 relationships at each level. The separation provides single responsibility, testability (each component testable in isolation), and future flexibility (e.g., if agents ever need to span projects). The separation is acknowledged as potentially anticipatory design, but documented and justified.


### Agent Hierarchy

```
Jake (daemon)
 └── Mortal Agent A (task-bound)
      ├── Child Agent A1
      ├── Child Agent A2
      │    └── Grandchild Agent A2a
      └── Child Agent A3
 └── Mortal Agent B (task-bound)
      └── ...
```


### Communication Patterns

- Agents can communicate upward (to parents), laterally (to siblings), or directly to user

- Messages bubble up through hierarchy unless agent has permission for direct contact

- Parent agents provide oversight for child-to-user communication

- Jake coordinates across all task trees


### Async Primitive Strategy

**Long-term direction:** AsyncStream/AsyncSequence (language-level concurrency)

**Current state:** SDK uses Combine for streaming, async/await for batch operations

**Boundaries:**

- `@Observable` at SwiftUI boundary

- AsyncStream for everything below

- Bridge once, at the ViewModel layer


### Session Management

- Perseverance mode: system sends continuation prompts

- Chat mode: user is in the loop for every pause

- Special messages: "calling" (user zooms in), "hanging up" (user zooms out)

- Session persistence uses UserDefaults (machine-local), keyed by project path

- Agent persistence uses UserDefaults (`PersistedAgent` type with id, name, sessionId, chatDescription)

- Session history rehydration reads from Claude's native JSONL files

- Jake's history requires JSON parsing (JSON-in-JSON: Claude's JSONL wraps Jake's structured JSON responses)


### Session Lifecycle (2026-02-01)

Session storage has two independent states with different requirements:

```
LOCAL STATE                    SERVER STATE
~/.claude/projects/            Anthropic's servers
┌─────────────────┐            ┌─────────────────┐
│ session.jsonl   │            │ Session context │
│ (transcript)    │            │ (resumable)     │
└────────┬────────┘            └────────┬────────┘
         │                              │
         │  30-day retention            │  Server-side TTL
         │  (Claude auto-cleanup)       │  (unknown duration)
         ▼                              ▼
┌─────────────────┐            ┌─────────────────┐
│ Archives        │            │ Expired/deleted │
│ (user backup)   │            │ (unrecoverable) │
└─────────────────┘            └─────────────────┘
```

- **History display** needs only the local JSONL file (read-only, no API)

- **Session resume** needs BOTH local file AND server-side state

- A session can be "displayable but not resumable" if server-side state expires

- Archives preserve local forensics but cannot resurrect server-side sessions


---


## 6. Sandbox and Isolation


### Preflight Checks

Every agent gets spawn-time verification before starting:

- Sandbox configured correctly

- Access to required resources

- No permissions prompts expected

- External accounts (AWS, etc.) authenticated and working

**Failure behavior:** Agent does not start; parent is notified with reason. No degraded mode — it's pass/fail.


### Five Sandbox Primitives

Mix and match per child agent. Parent picks settings at spawn.

1. **Changeset** — Overlay filesystem on project root. All writes go to the overlay. The changeset is the diff between original and overlay. Protects original content; another agent can review the changeset independently.

2. **Platform** — Where the agent program runs: Mac, container, cloud, or hybrid (cloud agent communicating with macOS app via protocol).

3. **Isolation** — VMs, containers, OS-level sandboxes. Handles tools that leak outside their expected scope (e.g., uv accessing ~/.uv). Agent can trash everything and be reaped/restarted.

4. **Outputs** — Network access control. What can the agent reach?

5. **Software** — OS choice: macOS, Linux, FreeBSD, etc.

**Key insight:** Source control is orthogonal to isolation. Changesets work across multiple repos, separate from git worktrees. This resolves the ?1 concern about worktree assumptions.


---


## 7. Core Systems


### Document Store (FOUNDATION)

The memory backbone of the entire system.

**Storage:** Markdown files on disk with jerry-rigged structured data enforcement (to start). Namespaced by document type.

**Multi-purpose:**

- Document storage (specs, PRDs, notes)

- Messaging system (with supporting daemons)

- Work queues (drone dispatch — when item appears, drone fires immediately)

**Authoritative source:** UI can show "direct from store" indicator (no LLM retranscription) to signal data integrity.

**Key principle:** If it's not in a file, it doesn't exist. The doc store is the blackboard. Agents communicate primarily through shared state in files.


### Session Storage Layers

Three distinct storage locations:

1. **Claude SDK** — conversation history, sessions (in `~/.claude/projects/`)

2. **`.tavern/` in project** — shareable config, templates, agent definitions (version-controllable)

3. **UserDefaults/iCloud** — personal state, session IDs, window positions, persisted agent list (not shared)


### Workflow Engine

Workflow = state machine. The engine helps agents work through step by step.

**Responsibilities:**

- Track and enforce workflow progress

- Manage workflow templates

- Surface open loops and incomplete steps

- Show status for long-running workflows

**Composability:** TBD — how workflows combine is not yet defined.


### Spec Engine (vague)

Correctness verification layer:

- Verify completed output matches the spec

- Detect if agent A destroyed agent B's work

- Check: did all agents complete all required tasks?

Details TBD.


### Starter Workflows

Pre-configured templates users can modify:

- **Rule of 5:** Five agent passes over a single output from initial prompt (multi-pass refinement)

- **Verification layers:** Progressive gates — linting, then code structure, then architecture, then performance, etc. Final output must pass all gates.


---


## 8. UI Concepts


### Dynamic View Architecture

The view layer isn't a fixed hierarchy — it's a composable surface that can be reshaped by both the user AND the agents.


**View System:**

- Composable, not fixed

- User AND agents can modify layout

- Tiles within windows, windows as macOS-level escape hatch

- Granular primitives (chat components can be split: thinking, tools, messages)


**Agent Hierarchy is Erlang-style:**

- Jake → subagents → gangs → sub-gangs, arbitrary depth

- View structure is independent — same agents can render as tree or flat


**View Modes, Not Routing:**

- Response stream (thinking, tools, text) stays in one place

- Different view modes present same data differently — like Finder's list/icon/column views

- Multiple tiles can show different view modes of the same agent


**Dead Agents Leave Bodies:**

- Tile persists showing final state for review/debugging

- Manual cleanup initially, sophisticated reaping later


### Persistence

**Two types:**

- Session restore — automatic, restore what was open on quit

- Saved layouts — named templates (abstract structure) AND concrete snapshots (specific agents, specific state)


### Agent Layout Tools

**Two tool categories with separate permissions:**

- Suggestions — "you might want a tile for Gang B" — user places it, can auto-reject

- Mutations — agent reads layout, modifies directly — requires permission


### Context Cards

Quick context for jumping into agent conversations:

- Agent name

- Current assignment

- Status right now

Lets user switch contexts without reading full chat history.


### Chat Header

A header component in each chat view showing the agent name and a "New Conversation" button (compose icon `square.and.pencil`, matching Apple's convention). Replaced the original in-input-bar button which looked like a file attachment action (transcript_2026-01-28).


### Content Block Rendering

Claude's responses include a `content` array with typed blocks:

- `text` — plain text content

- `tool_use` — tool invocation (name, input parameters as JSON)

- `tool_result` — result from tool (content, isError flag)

- `thinking` — Claude's thinking process

- `web_search_result` — web search output

Each block type has its own visual style in the UI (colored avatars, styled boxes).


---


## 9. Agent Communication


### Message Protocol

Certain message types expect certain response types. Wrong or missing response = agent malfunction signal.


### Jake's JSON Response Format

Jake's system prompt tells him to respond in structured JSON:
```json
{"message": "your response", "spawn": {"assignment": "task", "name": "optional"}}
```

The `JakeToolHandler` extracts the display message and executes any embedded actions (like spawning). Other agents respond in plain text — they don't need structured responses for orchestration.

**Continuation loop:** When the tool handler returns feedback (e.g., confirming a spawn succeeded), Jake receives it and can continue with additional actions. The loop continues until the handler returns nil feedback (transcript_2026-01-28).


### Lateral Collaboration

Messaging is not just for bubbling up. Agents can message each other to collaborate on work.


### Surfacing Questions (flexible modes)

Parent agent chooses approach for handling child questions:

- **Close collaboration:** Chat window pops up with notification

- **Overseer mode:** Periodic summary of outstanding questions

User modes: directing agents, answering questions, or doing their own thing.


### Sidecar Pattern

Each agent has TWO actor components:

1. **Main actor** — manages tree structure, never blocks

2. **Sidecar actor** — handles slow Anthropic I/O

This prevents thread pool starvation when many agents are making concurrent API calls. Global semaphore limits concurrent Anthropic calls (~10).


---


## 10. Design Principles

These principles govern development and are enforced as an honor system:


### Informative Error Principle

Error messages shown to users must be specific and actionable, not just "something went wrong." Map every error case to a meaningful message at design time.


### Sum Type Error Design

Use GADTs/sum types to enumerate all failure modes upfront. This forces comprehensive handling at design time rather than as an afterthought.


### Instrumentation Principle

Debug builds must be instrumented thoroughly enough that logs alone can narrow down issues without user explanation or screenshots.

**Logging categories:** `agents`, `chat`, `coordination`, `claude`

**Subsystem:** `com.tavern.spillway`


### Autonomous Testing Principle

Tests must run without human interaction. They should run and verify results automatically.

End-to-end integration tests over mocks — create real sessions via Claude CLI, verify the SDK can parse and rehydrate.


### Perception-Bounded Performance

"Fast" is not measured in milliseconds but in user perception. The app must remain responsive under all conditions.

**Core rules:**

1. **Isolation** — No operation impacts unrelated parts

2. **Responsiveness over speed** — UI always responds, show feedback

3. **Perception boundaries** — Zones where latency is expected (debug mode, search, cold start, network, agent work)

4. **Scale independence** — Visible slice stays fast regardless of history size


### Testing Principles (2026-01-27)

Five principles established after a mortal agent session history bug revealed systematic test gaps:

1. **Parallel Code Path Testing** — When code has multiple paths to the same outcome, tests must cover ALL paths. Two initializers that both should load history? Both need tests.

2. **Feature Toggle Coverage** — When tests disable a feature (`loadHistory: false`), there MUST be other tests that exercise that feature enabled.

3. **User Journey Integration Tests** — Test end-to-end paths users actually take. Spawn agent → send message → restart app → click agent → verify history appears.

4. **Symmetry Assertions** — When multiple APIs should behave consistently, add explicit tests that assert symmetry. Makes API drift a compile-time error.

5. **New Entity = New Test Coverage** — New entity types need equivalent test coverage to existing types. Jake has session restoration tests? MortalAgent needs them too.

**Origin:** A bug where `ChatViewModel(agent:)` didn't load session history (while `ChatViewModel(jake:)` did) went undetected because all tests disabled history loading. The principles prevent this class of gap (transcript_2026-01-27).


### App Restart Workflow

After rebuilding, kill and relaunch the app for testing. Use `redo Tavern/run`.


### Threading Decision

View state stays @MainActor. No reason to complicate with off-main-thread state. Persistence is just async I/O: serialize on main, write on background.


---


## 11. Open Questions

These questions were flagged during discovery for later resolution.


### ?1 — Worktree/Git Assumptions [RESOLVED]

**Resolution:** Do not use git worktrees. Use overlay filesystems orthogonal to git. Changesets work across multiple repos.


### ?2 — Deterministic Shell Meaning [DEFERRED]

What does "deterministic shell" mean concretely? Possibly a full workflow DSL or state machine.


### ?3 — Self Improvement Definition [DEFERRED]

What does "self improvement" mean? Options range from better logging to ML-based prompt optimization to evolutionary workflow design.


### ?4 — Agent "Done" Assertion [DEFERRED]

How do we know when a mortal agent's task is complete? Is it self-declared, parent-verified, or user-confirmed?


### ?5 — Bubbling Up Process [DEFERRED]

Exactly how does bubbling work? Does child ask parent who decides to escalate? Can messages skip levels? Is there prioritization?


### ?6 — Perseverance Prompts and Agent Lifecycle [DEFERRED]

What exactly is a perseverance prompt? What are the lifecycle states of an agent? What triggers transitions?


### ?7 — User Consent for New Chats [DEFERRED]

What does "100% clear they're OK with it" mean concretely? User preference settings? Contextual inference? Per-agent consent?


### ?8 — Sandboxing for Safety [PARTIALLY RESOLVED]

**Partial resolution:** Five sandbox primitives defined (Changeset, Platform, Isolation, Outputs, Software).

**Remaining:** Specific configurations for different scenarios, trust hierarchy details.


### ?9 — UI Stream Separation [PARTIALLY RESOLVED]

**Partial resolution:** View modes instead of routing. Same data, different presentations. Multiple views of same agent allowed.

**Remaining:** Specific implementation of component-based chat views.


### ?19 — Work Queues [PARTIALLY ADDRESSED]

Work queues live in the document store. Drones fire when items appear.

**Remaining:** Full specification of queue mechanics, priorities, dependencies.


---


## 12. Vocabulary Decisions


### Cogitation Verbs

The system uses "cogitation verbs" to describe agent processing states (displayed while agent is working). The vocabulary draws from Jewish cultural and linguistic traditions.

**Scope (711 entries):** Yiddish, Hebrew, Ladino, Judeo-Arabic, Talmudic Aramaic, Kabbalistic terminology, and terms from diaspora communities including Ethiopian, Yemeni, Bukharan, Mountain Jews, Karaite, and modern denominational movements.

**Inclusion criterion:** Groups that claim Jewish identity are included regardless of how disputed. Groups that differentiate themselves from Judaism (like Rastafarians, who claim Israelite rather than Jewish identity) are excluded.

**Usage:** Terms appear in natural forms; awkward -ing constructions are avoided (e.g., "farblondzhet" not "farblondzhet-ing").

See `vocab_cogitation-verbs_2026-01-19-1144.md` for the full list.


### Agent Naming Themes

Jake assigns naming themes to agent trees. Documented themes include:

- LOTR characters

- Rick and Morty

- Santa's reindeer (with escalating tier silliness)

- Docker-style compound names

- Jewish figures

See `vocab_naming-themes_2026-01-19-1144.md` for details.


### Terminology Note

Technical documentation uses plain names (perseverance mode, mortal agents, bubbling). Jake's colorful vocabulary (Slop Squad, Multi-Slop Madness, the Jukebox) is presentation layer only and does not appear in architecture or design documents.


### /conceive Command

The collaborative design interview process is captured in the `/conceive` slash command. Naming rationale:

- NOT "discovery" — implies finding existing things

- NOT "ideate/envision/conjure" — too abstract or fantastical

- YES "conceive" — generative and creative, implies bringing something real into existence


---


## 13. Conversation Chronicle

This section provides a chronological index of when topics were discussed. Use it to trace back to original discussions.


### Session 1 — Process Establishment (2026-01-19 09:06)

**File:** `transcript_2026-01-19-0906.md`

| Time | Topic | Notes |
|------|-------|-------|
| 09:06 | Process meta-setup | Two input sources established: verbal + initial_notes.md |
| 09:14 | Documentation location | docs/seed-design/ folder, datetime suffixes |
| 09:14 | Session continuity | User directs start, Claude figures out what to read |
| 09:19 | Transcript format | Notation system: [U], [C], [T], [S] tags |
| 09:24 | Format corrections | Proper list formatting, tag styling |
| 09:29 | Ready to start | Process established, ready for the idea |


### Session 1 — Problem Statement (2026-01-19 10:26)

**File:** `transcript_2026-01-19-1026.md`

| Time | Topic | Notes |
|------|-------|-------|
| 10:26 | 14 pain points listed | Attention, tooling, coordination, workflow, visibility |
| 10:31 | Framework-level concerns | 9 additional potential issues to plan for |
| 10:31 | Open questions system | [?] notation, verbose context requirement |


### Session 1 — User Flow (2026-01-19 10:40-12:00)

**File:** `transcript_2026-01-19-1144.md`

| Time | Topic | Notes |
|------|-------|-------|
| 10:40 | Core user flow | Jake as entry point, mortal agent spawning |
| 10:40 | 5 task modes | Execute, delegate, plan, break up, unify |
| 10:40 | Bubbling concept | Child agents escalate questions upward |
| 10:40 | Perseverance vs chat mode | Background vs active conversation |
| 10:40 | Zoom mechanics | Calling, hanging up, cogitating status |
| 10:40 | Platform decision | Mac app primary, GUI-less core, TUI equivalent |
| 10:40 | Jake's privileges | Least privileges by quantity, highest authority |
| 10:40 | Agent naming themes | LOTR, Rick & Morty, reindeer, Docker-style |
| 10:40 | Cogitation verbs intro | Jewish cultural vocabulary request |
| 11:57 | Tech stack | Claude Agent SDK, Swift/SwiftUI |


### Session 1 — Vocabulary (2026-01-19 12:00-12:30)

**File:** `transcript_2026-01-19-1144.md`

| Time | Topic | Notes |
|------|-------|-------|
| 12:00 | Ladino, Judeo-Arabic added | Expanding beyond Yiddish |
| 12:00 | Provenance policy | Terms must be backed by documented Jewish texts |
| 12:30 | Global diaspora coverage | Ethiopian, Greek, Caucasus, Central Asia |
| 12:30 | Inclusion criterion finalized | Claims Jewish identity = included |
| 12:30 | Final count | 711 entries |


### Session 1 — /conceive Command (2026-01-19 14:50)

**File:** `transcript_2026-01-19-1450-conceive-command.md`

| Time | Topic | Notes |
|------|-------|-------|
| 14:50 | Process documentation | Created `/conceive` slash command |
| 14:50 | Naming rationale | "discovery" too passive, "conceive" captures generative design |


### Session 2 — XcodeGen Setup (2026-01-20 23:15)

**File:** `transcript_2026-01-20-2315.md`

| Time | Topic | Notes |
|------|-------|-------|
| 23:15 | XcodeGen implementation | project.yml created, build workflow documented |
| 23:15 | Project root discovery | Jake's working directory needs configuration |
| 23:15 | LOC script | scripts/loc.sh for accurate line counts |


### Session 3 — Design Principles (2026-01-21 08:00)

**File:** `transcript_2026-01-21-0800.md`

| Time | Topic | Notes |
|------|-------|-------|
| 08:00 | Architecture docs | docs/architecture-v1.md created |
| 08:00 | SDK bug discovered | JSON array vs object parsing mismatch |
| 08:00 | Informative Error Principle | Errors must be specific and actionable |
| 08:00 | Sum Type Error Design | Enumerate failure modes via GADTs |
| 08:00 | Autonomous Testing Principle | Tests run without human interaction |
| 08:00 | Instrumentation Principle | Logs must diagnose without screenshots |
| 08:00 | App Restart Workflow | Kill and relaunch after rebuilding |


### Session 4 — Performance Requirements (2026-01-21 15:00)

**File:** `transcript_2026-01-21-1500.md`

| Time | Topic | Notes |
|------|-------|-------|
| 15:00 | Handoff docs created | Project context for session continuity |
| 15:00 | Performance requirements | Perception-bounded performance principle |
| 15:00 | Build path | Changed to ~/.local/builds/tavern |


### Session 5 — Perception-Bounded Performance (2026-01-21 21:13)

**File:** `transcript_2026-01-21-2113-performance.md`

| Time | Topic | Notes |
|------|-------|-------|
| 21:13 | Perception boundaries defined | Zones where users expect delay |
| 21:13 | Isolation principle | Heavy ops don't impact unrelated work |
| 21:13 | Scale independence | Visible slice stays fast regardless of history |
| 21:13 | Stress testing requirement | Mandatory performance testing |


### Session 6 — Instrumentation & Stress Testing (2026-01-21 16:20)

**File:** `transcript_2026-01-21-1620.md`

| Time | Topic | Notes |
|------|-------|-------|
| 16:20 | TavernLogger created | Categories: agents, chat, coordination, claude |
| 16:20 | Stress test suite | 8 tests for message volume, spawn cycles, threading |
| 16:20 | Progressive unlocks | PRD section for engagement-based content |


### Session 7 — Dynamic View Architecture (2026-01-21 23:45)

**File:** `transcript_2026-01-21-2345.md`

| Time | Topic | Notes |
|------|-------|-------|
| 23:45 | Composable views | User and agents can reshape layout |
| 23:45 | Erlang-style depth | Arbitrary depth agent hierarchies |
| 23:45 | View modes | Same data, different presentations (like Finder) |
| 23:45 | Dead agents leave bodies | Tiles persist for review |
| 23:45 | Templates vs snapshots | Abstract layouts vs concrete state |
| 23:45 | Threading decision | View state stays @MainActor |


### Session 8 — Document-Based Architecture (2026-01-22 00:15)

**File:** `transcript_2026-01-22-0015.md`

| Time | Topic | Notes |
|------|-------|-------|
| 00:15 | Project-as-document | Any directory works, like Claude CLI |
| 00:15 | Three storage layers | Claude SDK, .tavern/, UserDefaults/iCloud |
| 00:15 | Multi-window support | Each project = separate window |
| 00:15 | Full Mac app trappings | File menus, Dock integration, Open Recent |
| 00:15 | Path B confirmed | Custom open flow, any folder works |


### Session 9 — View Architecture Deep Dive (2026-01-22 07:30)

**File:** `transcript_2026-01-22-0730-view-architecture.md`

| Time | Topic | Notes |
|------|-------|-------|
| 07:30 | ViewModel rationale | Separation of concerns, agent abstraction, testability |
| 07:30 | Agent layout tools | Suggestions vs mutations with different permissions |
| 07:30 | Component-based chat | Thinking, tools, messages as separate components |
| 07:30 | Tree vs flat hierarchy | View structure independent of agent hierarchy |


### Session 10 — SDK Fix & Implementation (2026-01-22 14:30)

**File:** `transcript_2026-01-22-1430.md`

| Time | Topic | Notes |
|------|-------|-------|
| 14:30 | SDK fork decision | Local fork to fix JSON parsing |
| 14:30 | Content blocks infrastructure | MessageType enum, block-aware rendering |
| 14:30 | Agent spawn UI | Toolbar + button, spawn sheet |
| 14:30 | Session persistence | UserDefaults, keyed by project path |


### Session 11 — Redo Build System (2026-01-22 16:00)

**File:** `transcript_2026-01-22-1600.md`

| Time | Topic | Notes |
|------|-------|-------|
| 16:00 | Redo build scripts | build.do, run.do, test.do, clean.do, etc. |
| 16:00 | Handoff consolidation | Merged into CLAUDE.md |
| 16:00 | Output to stderr | redo convention for .do scripts |


### Session 12 — Jake's Politics (2026-01-22 17:00)

**File:** `transcript_2026-01-22-1700.md`

| Time | Topic | Notes |
|------|-------|-------|
| 17:00 | Political stance | Absurdist deflection by default |
| 17:00 | The hard line | Nazis not tolerated |
| 17:00 | Jake is Jewish | The kids know, some had b'nei mitzvah at the Tavern |
| 17:00 | Nazi bar story | Documented accurately |


### Session 13 — Session Rehydration (2026-01-22 21:00 + additional)

**Files:** `transcript_2026-01-22-2100.md`, `transcript_2026-01-22-session-rehydration.md`

| Time | Topic | Notes |
|------|-------|-------|
| 21:00 | Blank lines issue | Tool use/result blocks not rendering |
| 21:00 | StoredContentBlock enum | Preserves content block structure |
| 21:00 | JSONValue helper | Parses arbitrary JSON for tool inputs |
| — | Path encoding bugs | Symlink resolution, underscore replacement |
| — | Integration tests | Real Claude sessions, end-to-end parsing |
| — | Debug logging visibility | .public privacy in DEBUG builds |


### Session 14 — Headless Testing Philosophy (2026-01-23)

**File:** `transcript_2026-01-23-headless-testing.md`

| Time | Topic | Notes |
|------|-------|-------|
| — | GUI debugging anti-pattern | Apps background, can't observe manually |
| — | End-to-end over stubs | Stubs test parser, integration tests test reality |
| — | Testing strategy = debugging strategy | Headless tests enable programmatic debugging |


### Session 15 — Architecture Exploration (2026-01-24)

**File:** `transcript_2026-01-24-architecture-exploration.md`

| Time | Topic | Notes |
|------|-------|-------|
| — | Parallel exploration methodology | Spawn many agents, each explores one architecture |
| — | 49 proposals generated | Across 16 fundamental shapes |
| — | Two-document output | 1-page summary + complete treatise per architecture |
| — | Synthesis report | 122-pair compatibility matrix with explanations |


### Session 16 — Shape Selection (2026-01-24)

**File:** `transcript_2026-01-24-shape-selection.md`

| Time | Topic | Notes |
|------|-------|-------|
| — | Final shape selection | E + D + A + I + C + L |
| — | ADR-001 created | Documents decision with rationale |
| — | ViewModel layer added | Thin UI / Fat ViewModel pattern |
| — | Cellular/emergent rejected | Too speculative for v1 |


### Session 17 — Async Primitive Strategy (2026-01-24)

**File:** `transcript_2026-01-24-async-primitives.md`

| Time | Topic | Notes |
|------|-------|-------|
| — | Long-term direction | AsyncStream/AsyncSequence |
| — | SDK reality | Uses Combine for streaming, async/await for batch |
| — | @Observable explained | Pull-based, tracks what you read |
| — | Bridge at ViewModel | Combine at boundary, async below |


### Session 18 — Window Restoration (2026-01-24)

**File:** `transcript_2026-01-24-window-restoration.md`

| Time | Topic | Notes |
|------|-------|-------|
| — | Multi-window implemented | WindowOpeningService bridges AppKit ↔ SwiftUI |
| — | Per-project sessions | Session keys include encoded project path |
| — | App icon created | Orange squircle with JT in Luminari |
| — | Window restoration bug | .task(id:) pattern for dependent values |
| — | GUI instrumentation guide | docs/gui-instrumentation-guide.md created |
| — | Jake character extracted | docs/jake-character.md |


### Session 19 — Transcript Audit (2026-01-25)

**File:** `transcript_2026-01-25-transcript-audit.md`

| Time | Topic | Notes |
|------|-------|-------|
| — | Parallel verification | 7 rewind agents by date range |
| — | One-transcript-per-agent rule | Prevents contamination |
| — | 3 gaps found and repaired | conceive command, view architecture, architecture exploration |
| — | /audit-transcripts command | Created for future maintenance |


### Session 20 — Agent Registry Architecture (2026-01-25 01:08)

**File:** `transcript_2026-01-25-0108-agent-registry-architecture.md`

| Time | Topic | Notes |
|------|-------|-------|
| 01:08 | AgentRegistry justification | Single source of truth, name uniqueness, thread safety, type erasure |
| 01:08 | Architecture docs audit | Docs significantly outdated vs codebase reality |
| 01:08 | 1:1 relationship chain | TavernProject → Coordinator → Spawner → Registry |
| 01:08 | ProjectManager is the only singleton | Coordinator is NOT a singleton |
| 01:08 | TavernProject vs Coordinator | Identity vs behavior separation — possibly anticipatory |
| 01:48 | Synthesis | 1:1 relationships are a code smell, but separation justified by testability |


### Session 21 — Testing Principles & Agent Spawning (2026-01-27)

**File:** `transcript_2026-01-27-testing-principles.md`

| Time | Topic | Notes |
|------|-------|-------|
| — | Two-mode spawn design | User-spawn (waits) vs Jake-spawn (works immediately) |
| — | Spawn dialog removed | `+` button creates agent instantly |
| — | Agent persistence | PersistedAgent type, UserDefaults storage |
| — | Chat description field | Mutable, visible in sidebar, user and agent editable |
| — | Sidebar selection bug | SwiftUI List selection binding unreliable, fixed with onTapGesture |
| — | Platform policy | macOS 26+ (Tahoe) only |
| — | Log helper scripts | logs.sh, logs-stream.sh, logs-category.sh, logs-errors.sh |
| — | Session history bug | ChatViewModel(agent:) didn't call loadSessionHistory() |
| — | Testing principles established | 5 principles from analyzing the session history bug |
| — | 7 new tests added | Covering parallel paths, symmetry, user journeys |
| — | Jake character note | Git HEAD puns (multi-layered wordplay) |


### Session 22 — Jake Spawn Tool (2026-01-28)

**File:** `transcript_2026-01-28-jake-spawn-tool.md`

| Time | Topic | Notes |
|------|-------|-------|
| — | JakeToolHandler protocol | Swappable design for future SDK migration |
| — | JSONActionHandler | Parses {"message", "spawn"} JSON format |
| — | Continuation loop | Tool results feed back to Jake for multi-action sequences |
| — | Actor isolation fixes | MainActor.run for UI updates from non-main context |
| — | Test state pollution | SessionStore.clearAgentList() for test isolation |
| — | Testing principles applied | 8 new tests covering all code paths |
| — | Two-level orchestration model | Tavern agents (persistent) vs Task subagents (ephemeral) |
| — | ChatHeader component | Compose icon, Apple convention, header placement |
| — | Test count: 200 | Up from 192 |


### Session 23 — SDK Migration & Session Forensics (2026-02-01)

**File:** `transcript_2026-02-01-sdk-migration-and-session-forensics.md`

| Time | Topic | Notes |
|------|-------|-------|
| — | ClodeMonster SDK migration | Protocol-based → static function API |
| — | API mapping | Old vs new SDK interfaces documented |
| — | Testing impact | No dependency injection → mocking requires different approach |
| — | Jake's JSON-in-JSON | Claude's JSONL wraps Jake's structured JSON responses |
| — | Session history fix | parseJakeMessage() added for JSON extraction in history |
| — | Session forensics | Corrupt session: displayable but not resumable |
| — | Session lifecycle model | Local state vs server state independence |
| — | Archives can't resurrect | Server-side session state is unrecoverable once expired |


### Session 24 — Transcript Audit System (2026-02-02 06:57)

**File:** `transcript_2026-02-02-0657-transcript-audit-system.md`

| Time | Topic | Notes |
|------|-------|-------|
| — | Audit execution | Full /audit-transcripts run documented |
| — | Three-phase process | Discovery → Parallel Verification → Repair |
| — | Agent prompt design | STATUS/VERIFIED_SESSIONS/VERIFIED_TOPICS format |
| — | Design vs transcription sessions | Not every large session needs a transcript |
| — | Recursive transcription | This audit is itself a META-META transcription |
| — | When to transcribe META sessions | Only when process evolution/methodology insights emerge |


### Session 25 — Worktree-Aware Audit (2026-02-05)

**File:** `transcript_2026-02-05-worktree-aware-audit.md`

| Time | Topic | Notes |
|------|-------|-------|
| — | Worktree duplication problem | ccmanager creates session copies per worktree path |
| — | list-project-dirs.sh | Enumerates worktrees, encodes paths, checks existence |
| — | list-sessions.sh | Session discovery with dedup by ID (newest mtime wins) |
| — | Script composability | Discovery infra reusable beyond audit (stats, cleanup) |
| — | User completeness check | Agent prompt: verify EVERYTHING user said is captured |
| — | Audit methodology maturation | From "important content covered" to "no user content lost" |


---


## 14. Key Decision Points

Major decisions and their locations:

| Decision | Location | Summary |
|----------|----------|---------|
| Jake as daemon | transcript_1144, 10:40 | Always running, spawns mortal agents |
| Perseverance mode | transcript_1144, 10:40 | Auto-continue, no user notification |
| Chat mode | transcript_1144, 10:40 | Active conversation, user notified |
| Bubbling is multi-directional | transcript_1144, 11:57 | Upward, lateral, and direct-to-user |
| Tech stack: Swift/SwiftUI | transcript_1144, 11:57 | Mac primary, SDK not TUI wrapper |
| Plain names for components | transcript_1144, 11:59 | Character names are Jake's voice only |
| Vocabulary provenance | transcript_1144, 12:00 | Documented Jewish texts required |
| Inclusion criterion | transcript_1144, 12:30 | Claims Jewish identity = included |
| Agent names globally unique | transcript_1144 | No path addressing needed for identity |
| Tier depletion for naming | transcript_1144 | Exhaust less silly before sillier |
| Five sandbox primitives | transcript_1144 walkthrough | Changeset, Platform, Isolation, Outputs, Software |
| Document store is foundation | transcript_1144 walkthrough | Memory backbone, messaging, work queues |
| SDK fork for JSON fix | transcript_2026-01-22-1430 | Local fork at LocalPackages/ClaudeCodeSDK |
| Session persistence in UserDefaults | transcript_2026-01-22-1430 | Per-project, keyed by path |
| Thin UI / Fat ViewModel | transcript_2026-01-24-shape-selection | 90%+ of UX testable without SwiftUI |
| Architecture shapes: E+D+A+I+C+L | transcript_2026-01-24-shape-selection | Shared Workspace, Supervisor Tree, Reactive, Plugin, Layer, Sidecar |
| AsyncStream long-term | transcript_2026-01-24-async-primitives | Language features over framework |
| .task(id:) for dependent values | transcript_2026-01-24-window-restoration | SwiftUI view instance confusion fix |
| 1:1 component chain justified | transcript_2026-01-25-0108 | Testability and SRP outweigh simplicity concern |
| Two-mode agent spawn | transcript_2026-01-27 | User-spawn waits, Jake-spawn works immediately |
| macOS 26+ only | transcript_2026-01-27 | No backwards compatibility maintenance |
| Testing principles codified | transcript_2026-01-27 | 5 principles from session history bug analysis |
| Swappable tool handler protocol | transcript_2026-01-28 | Future SDK migration without touching Jake core |
| Two-level orchestration | transcript_2026-01-28 | Tavern agents (persistent) vs Task subagents (ephemeral) |
| SDK migration to ClodeMonster | transcript_2026-02-01 | Static function API, lost DI for testing |
| Session lifecycle: dual state | transcript_2026-02-01 | Local file for display, server state for resume |
| User completeness principle | transcript_2026-02-05 | Transcripts must capture ALL user statements |


---


## 15. Source Files

| File | Purpose |
|------|---------|
| `transcript_2026-01-19-0906.md` | Process establishment |
| `transcript_2026-01-19-1026.md` | Problem statement, pain points |
| `transcript_2026-01-19-1144.md` | User flow, architecture, vocabulary |
| `transcript_2026-01-19-1450-conceive-command.md` | /conceive command creation |
| `transcript_2026-01-20-2315.md` | XcodeGen setup, project root |
| `transcript_2026-01-21-0800.md` | Architecture docs, design principles, SDK bug |
| `transcript_2026-01-21-1500.md` | Handoff docs, performance requirements |
| `transcript_2026-01-21-1620.md` | Instrumentation, stress testing |
| `transcript_2026-01-21-2113-performance.md` | Perception-bounded performance |
| `transcript_2026-01-21-2345.md` | Dynamic view architecture |
| `transcript_2026-01-22-0015.md` | Document-based architecture |
| `transcript_2026-01-22-0730-view-architecture.md` | View architecture deep dive |
| `transcript_2026-01-22-1430.md` | SDK fix, content blocks, agent spawn |
| `transcript_2026-01-22-1600.md` | Redo build system |
| `transcript_2026-01-22-1700.md` | Jake's politics |
| `transcript_2026-01-22-2100.md` | Session history content blocks |
| `transcript_2026-01-22-session-rehydration.md` | Full session rehydration implementation |
| `transcript_2026-01-23-headless-testing.md` | Autonomous testing philosophy |
| `transcript_2026-01-24-architecture-exploration.md` | Parallel exploration methodology |
| `transcript_2026-01-24-shape-selection.md` | Architecture decision, ADR-001 |
| `transcript_2026-01-24-async-primitives.md` | Async primitive strategy |
| `transcript_2026-01-24-window-restoration.md` | Multi-window, app icon, GUI instrumentation |
| `transcript_2026-01-25-transcript-audit.md` | Parallel transcript audit methodology |
| `transcript_2026-01-25-0108-agent-registry-architecture.md` | Agent registry analysis, 1:1 relationships |
| `transcript_2026-01-27-testing-principles.md` | Two-mode spawn, testing principles, platform policy |
| `transcript_2026-01-28-jake-spawn-tool.md` | Jake tool handler, spawn tool, two-level orchestration |
| `transcript_2026-02-01-sdk-migration-and-session-forensics.md` | ClodeMonster SDK migration, session lifecycle |
| `transcript_2026-02-02-0657-transcript-audit-system.md` | Audit system execution, design vs transcription sessions |
| `transcript_2026-02-05-worktree-aware-audit.md` | Worktree-aware session discovery, user completeness |
| `process_2026-01-19-0906.md` | Open questions, meta-process |
| `vocab_cogitation-verbs_2026-01-19-1144.md` | 711 cogitation verbs |
| `vocab_naming-themes_2026-01-19-1144.md` | Agent naming themes |
| `notes_issues-to-plan-for_2026-01-19-1031.md` | Framework-level concerns |
| `prd_2026-01-19.md` | Product requirements document |
| `v1-implementation-plan.md` | Implementation roadmap |
| `project-status.md` | Current feature status |
